"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-xml-parser";
exports.ids = ["vendor-chunks/fast-xml-parser"];
exports.modules = {

/***/ "(rsc)/../node_modules/fast-xml-parser/src/ignoreAttributes.js":
/*!***************************************************************!*\
  !*** ../node_modules/fast-xml-parser/src/ignoreAttributes.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getIgnoreAttributesFn)\n/* harmony export */ });\nfunction getIgnoreAttributesFn(ignoreAttributes) {\n    if (typeof ignoreAttributes === \"function\") {\n        return ignoreAttributes;\n    }\n    if (Array.isArray(ignoreAttributes)) {\n        return (attrName)=>{\n            for (const pattern of ignoreAttributes){\n                if (typeof pattern === \"string\" && attrName === pattern) {\n                    return true;\n                }\n                if (pattern instanceof RegExp && pattern.test(attrName)) {\n                    return true;\n                }\n            }\n        };\n    }\n    return ()=>false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMvaWdub3JlQXR0cmlidXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsU0FBU0Esc0JBQXNCQyxnQkFBZ0I7SUFDMUQsSUFBSSxPQUFPQSxxQkFBcUIsWUFBWTtRQUN4QyxPQUFPQTtJQUNYO0lBQ0EsSUFBSUMsTUFBTUMsT0FBTyxDQUFDRixtQkFBbUI7UUFDakMsT0FBTyxDQUFDRztZQUNKLEtBQUssTUFBTUMsV0FBV0osaUJBQWtCO2dCQUNwQyxJQUFJLE9BQU9JLFlBQVksWUFBWUQsYUFBYUMsU0FBUztvQkFDckQsT0FBTztnQkFDWDtnQkFDQSxJQUFJQSxtQkFBbUJDLFVBQVVELFFBQVFFLElBQUksQ0FBQ0gsV0FBVztvQkFDckQsT0FBTztnQkFDWDtZQUNKO1FBQ0o7SUFDSjtJQUNBLE9BQU8sSUFBTTtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWRhc2hib2FyZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy9pZ25vcmVBdHRyaWJ1dGVzLmpzP2M1ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SWdub3JlQXR0cmlidXRlc0ZuKGlnbm9yZUF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodHlwZW9mIGlnbm9yZUF0dHJpYnV0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGlnbm9yZUF0dHJpYnV0ZXNcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaWdub3JlQXR0cmlidXRlcykpIHtcbiAgICAgICAgcmV0dXJuIChhdHRyTmFtZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGlnbm9yZUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnICYmIGF0dHJOYW1lID09PSBwYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwICYmIHBhdHRlcm4udGVzdChhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgpID0+IGZhbHNlXG59Il0sIm5hbWVzIjpbImdldElnbm9yZUF0dHJpYnV0ZXNGbiIsImlnbm9yZUF0dHJpYnV0ZXMiLCJBcnJheSIsImlzQXJyYXkiLCJhdHRyTmFtZSIsInBhdHRlcm4iLCJSZWdFeHAiLCJ0ZXN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/fast-xml-parser/src/ignoreAttributes.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/fast-xml-parser/src/util.js":
/*!***************************************************!*\
  !*** ../node_modules/fast-xml-parser/src/util.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAllMatches: () => (/* binding */ getAllMatches),\n/* harmony export */   getValue: () => (/* binding */ getValue),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExist: () => (/* binding */ isExist),\n/* harmony export */   isName: () => (/* binding */ isName),\n/* harmony export */   merge: () => (/* binding */ merge),\n/* harmony export */   nameRegexp: () => (/* binding */ nameRegexp)\n/* harmony export */ });\n\nconst nameStartChar = \":A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\nconst nameChar = nameStartChar + \"\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\nconst nameRegexp = \"[\" + nameStartChar + \"][\" + nameChar + \"]*\";\nconst regexName = new RegExp(\"^\" + nameRegexp + \"$\");\nfunction getAllMatches(string, regex) {\n    const matches = [];\n    let match = regex.exec(string);\n    while(match){\n        const allmatches = [];\n        allmatches.startIndex = regex.lastIndex - match[0].length;\n        const len = match.length;\n        for(let index = 0; index < len; index++){\n            allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex.exec(string);\n    }\n    return matches;\n}\nconst isName = function(string) {\n    const match = regexName.exec(string);\n    return !(match === null || typeof match === \"undefined\");\n};\nfunction isExist(v) {\n    return typeof v !== \"undefined\";\n}\nfunction isEmptyObject(obj) {\n    return Object.keys(obj).length === 0;\n}\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */ function merge(target, a, arrayMode) {\n    if (a) {\n        const keys = Object.keys(a); // will return an array of own properties\n        const len = keys.length; //don't make it inline\n        for(let i = 0; i < len; i++){\n            if (arrayMode === \"strict\") {\n                target[keys[i]] = [\n                    a[keys[i]]\n                ];\n            } else {\n                target[keys[i]] = a[keys[i]];\n            }\n        }\n    }\n}\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */ function getValue(v) {\n    if (exports.isExist(v)) {\n        return v;\n    } else {\n        return \"\";\n    }\n} // const fakeCall = function(a) {return a;};\n // const fakeCallNoReturn = function() {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMvdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFFQSxNQUFNQSxnQkFBZ0I7QUFDdEIsTUFBTUMsV0FBV0QsZ0JBQWdCO0FBQzFCLE1BQU1FLGFBQWEsTUFBTUYsZ0JBQWdCLE9BQU9DLFdBQVcsS0FBSztBQUN2RSxNQUFNRSxZQUFZLElBQUlDLE9BQU8sTUFBTUYsYUFBYTtBQUV6QyxTQUFTRyxjQUFjQyxNQUFNLEVBQUVDLEtBQUs7SUFDekMsTUFBTUMsVUFBVSxFQUFFO0lBQ2xCLElBQUlDLFFBQVFGLE1BQU1HLElBQUksQ0FBQ0o7SUFDdkIsTUFBT0csTUFBTztRQUNaLE1BQU1FLGFBQWEsRUFBRTtRQUNyQkEsV0FBV0MsVUFBVSxHQUFHTCxNQUFNTSxTQUFTLEdBQUdKLEtBQUssQ0FBQyxFQUFFLENBQUNLLE1BQU07UUFDekQsTUFBTUMsTUFBTU4sTUFBTUssTUFBTTtRQUN4QixJQUFLLElBQUlFLFFBQVEsR0FBR0EsUUFBUUQsS0FBS0MsUUFBUztZQUN4Q0wsV0FBV00sSUFBSSxDQUFDUixLQUFLLENBQUNPLE1BQU07UUFDOUI7UUFDQVIsUUFBUVMsSUFBSSxDQUFDTjtRQUNiRixRQUFRRixNQUFNRyxJQUFJLENBQUNKO0lBQ3JCO0lBQ0EsT0FBT0U7QUFDVDtBQUVPLE1BQU1VLFNBQVMsU0FBU1osTUFBTTtJQUNuQyxNQUFNRyxRQUFRTixVQUFVTyxJQUFJLENBQUNKO0lBQzdCLE9BQU8sQ0FBRUcsQ0FBQUEsVUFBVSxRQUFRLE9BQU9BLFVBQVUsV0FBVTtBQUN4RCxFQUFDO0FBRU0sU0FBU1UsUUFBUUMsQ0FBQztJQUN2QixPQUFPLE9BQU9BLE1BQU07QUFDdEI7QUFFTyxTQUFTQyxjQUFjQyxHQUFHO0lBQy9CLE9BQU9DLE9BQU9DLElBQUksQ0FBQ0YsS0FBS1IsTUFBTSxLQUFLO0FBQ3JDO0FBRUE7Ozs7Q0FJQyxHQUNNLFNBQVNXLE1BQU1DLE1BQU0sRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ3hDLElBQUlELEdBQUc7UUFDTCxNQUFNSCxPQUFPRCxPQUFPQyxJQUFJLENBQUNHLElBQUkseUNBQXlDO1FBQ3RFLE1BQU1aLE1BQU1TLEtBQUtWLE1BQU0sRUFBRSxzQkFBc0I7UUFDL0MsSUFBSyxJQUFJZSxJQUFJLEdBQUdBLElBQUlkLEtBQUtjLElBQUs7WUFDNUIsSUFBSUQsY0FBYyxVQUFVO2dCQUMxQkYsTUFBTSxDQUFDRixJQUFJLENBQUNLLEVBQUUsQ0FBQyxHQUFHO29CQUFFRixDQUFDLENBQUNILElBQUksQ0FBQ0ssRUFBRSxDQUFDO2lCQUFFO1lBQ2xDLE9BQU87Z0JBQ0xILE1BQU0sQ0FBQ0YsSUFBSSxDQUFDSyxFQUFFLENBQUMsR0FBR0YsQ0FBQyxDQUFDSCxJQUFJLENBQUNLLEVBQUUsQ0FBQztZQUM5QjtRQUNGO0lBQ0Y7QUFDRjtBQUNBOztFQUVFLEdBRUssU0FBU0MsU0FBU1YsQ0FBQztJQUN4QixJQUFJVyxRQUFRWixPQUFPLENBQUNDLElBQUk7UUFDdEIsT0FBT0E7SUFDVCxPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0YsRUFFQSw0Q0FBNEM7Q0FDNUMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FsZXMtZGFzaGJvYXJkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3V0aWwuanM/Y2E0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG5hbWVTdGFydENoYXIgPSAnOkEtWmEtel9cXFxcdTAwQzAtXFxcXHUwMEQ2XFxcXHUwMEQ4LVxcXFx1MDBGNlxcXFx1MDBGOC1cXFxcdTAyRkZcXFxcdTAzNzAtXFxcXHUwMzdEXFxcXHUwMzdGLVxcXFx1MUZGRlxcXFx1MjAwQy1cXFxcdTIwMERcXFxcdTIwNzAtXFxcXHUyMThGXFxcXHUyQzAwLVxcXFx1MkZFRlxcXFx1MzAwMS1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZGRCc7XG5jb25zdCBuYW1lQ2hhciA9IG5hbWVTdGFydENoYXIgKyAnXFxcXC0uXFxcXGRcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCc7XG5leHBvcnQgY29uc3QgbmFtZVJlZ2V4cCA9ICdbJyArIG5hbWVTdGFydENoYXIgKyAnXVsnICsgbmFtZUNoYXIgKyAnXSonO1xuY29uc3QgcmVnZXhOYW1lID0gbmV3IFJlZ0V4cCgnXicgKyBuYW1lUmVnZXhwICsgJyQnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbE1hdGNoZXMoc3RyaW5nLCByZWdleCkge1xuICBjb25zdCBtYXRjaGVzID0gW107XG4gIGxldCBtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgd2hpbGUgKG1hdGNoKSB7XG4gICAgY29uc3QgYWxsbWF0Y2hlcyA9IFtdO1xuICAgIGFsbG1hdGNoZXMuc3RhcnRJbmRleCA9IHJlZ2V4Lmxhc3RJbmRleCAtIG1hdGNoWzBdLmxlbmd0aDtcbiAgICBjb25zdCBsZW4gPSBtYXRjaC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbjsgaW5kZXgrKykge1xuICAgICAgYWxsbWF0Y2hlcy5wdXNoKG1hdGNoW2luZGV4XSk7XG4gICAgfVxuICAgIG1hdGNoZXMucHVzaChhbGxtYXRjaGVzKTtcbiAgICBtYXRjaCA9IHJlZ2V4LmV4ZWMoc3RyaW5nKTtcbiAgfVxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuZXhwb3J0IGNvbnN0IGlzTmFtZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICBjb25zdCBtYXRjaCA9IHJlZ2V4TmFtZS5leGVjKHN0cmluZyk7XG4gIHJldHVybiAhKG1hdGNoID09PSBudWxsIHx8IHR5cGVvZiBtYXRjaCA9PT0gJ3VuZGVmaW5lZCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFeGlzdCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5T2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5cbi8qKlxuICogQ29weSBhbGwgdGhlIHByb3BlcnRpZXMgb2YgYSBpbnRvIGIuXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZSh0YXJnZXQsIGEsIGFycmF5TW9kZSkge1xuICBpZiAoYSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhKTsgLy8gd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygb3duIHByb3BlcnRpZXNcbiAgICBjb25zdCBsZW4gPSBrZXlzLmxlbmd0aDsgLy9kb24ndCBtYWtlIGl0IGlubGluZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhcnJheU1vZGUgPT09ICdzdHJpY3QnKSB7XG4gICAgICAgIHRhcmdldFtrZXlzW2ldXSA9IFsgYVtrZXlzW2ldXSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tleXNbaV1dID0gYVtrZXlzW2ldXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qIGV4cG9ydHMubWVyZ2UgPWZ1bmN0aW9uIChiLGEpe1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihiLGEpO1xufSAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWUodikge1xuICBpZiAoZXhwb3J0cy5pc0V4aXN0KHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8vIGNvbnN0IGZha2VDYWxsID0gZnVuY3Rpb24oYSkge3JldHVybiBhO307XG4vLyBjb25zdCBmYWtlQ2FsbE5vUmV0dXJuID0gZnVuY3Rpb24oKSB7fTsiXSwibmFtZXMiOlsibmFtZVN0YXJ0Q2hhciIsIm5hbWVDaGFyIiwibmFtZVJlZ2V4cCIsInJlZ2V4TmFtZSIsIlJlZ0V4cCIsImdldEFsbE1hdGNoZXMiLCJzdHJpbmciLCJyZWdleCIsIm1hdGNoZXMiLCJtYXRjaCIsImV4ZWMiLCJhbGxtYXRjaGVzIiwic3RhcnRJbmRleCIsImxhc3RJbmRleCIsImxlbmd0aCIsImxlbiIsImluZGV4IiwicHVzaCIsImlzTmFtZSIsImlzRXhpc3QiLCJ2IiwiaXNFbXB0eU9iamVjdCIsIm9iaiIsIk9iamVjdCIsImtleXMiLCJtZXJnZSIsInRhcmdldCIsImEiLCJhcnJheU1vZGUiLCJpIiwiZ2V0VmFsdWUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/fast-xml-parser/src/util.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/fast-xml-parser/src/validator.js":
/*!********************************************************!*\
  !*** ../node_modules/fast-xml-parser/src/validator.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(rsc)/../node_modules/fast-xml-parser/src/util.js\");\n\n\nconst defaultOptions = {\n    allowBooleanAttributes: false,\n    unpairedTags: []\n};\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nfunction validate(xmlData, options) {\n    options = Object.assign({}, defaultOptions, options);\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n    const tags = [];\n    let tagFound = false;\n    //indicates that the root tag has been closed (aka. depth 0 has been reached)\n    let reachedRoot = false;\n    if (xmlData[0] === \"\\uFEFF\") {\n        // check for byte order mark (BOM)\n        xmlData = xmlData.substr(1);\n    }\n    for(let i = 0; i < xmlData.length; i++){\n        if (xmlData[i] === \"<\" && xmlData[i + 1] === \"?\") {\n            i += 2;\n            i = readPI(xmlData, i);\n            if (i.err) return i;\n        } else if (xmlData[i] === \"<\") {\n            //starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n            let tagStartPos = i;\n            i++;\n            if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {\n                    //closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for(; i < xmlData.length && xmlData[i] !== \">\" && xmlData[i] !== \" \" && xmlData[i] !== \"\t\" && xmlData[i] !== \"\\n\" && xmlData[i] !== \"\\r\"; i++){\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n                if (tagName[tagName.length - 1] === \"/\") {\n                    //self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    //continue;\n                    i--;\n                }\n                if (!validateTagName(tagName)) {\n                    let msg;\n                    if (tagName.trim().length === 0) {\n                        msg = \"Invalid space after '<'.\";\n                    } else {\n                        msg = \"Tag '\" + tagName + \"' is an invalid name.\";\n                    }\n                    return getErrorObject(\"InvalidTag\", msg, getLineNumberForPosition(xmlData, i));\n                }\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return getErrorObject(\"InvalidAttr\", \"Attributes for '\" + tagName + \"' have open quote.\", getLineNumberForPosition(xmlData, i));\n                }\n                let attrStr = result.value;\n                i = result.index;\n                if (attrStr[attrStr.length - 1] === \"/\") {\n                    //self closing tag\n                    const attrStrStart = i - attrStr.length;\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid === true) {\n                        tagFound = true;\n                    //continue; //text may presents after self closing tag\n                    } else {\n                        //the result from the nested function returns the position of the error within the attribute\n                        //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n                        //this gives us the absolute index in the entire xml, which we can use to find the line at last\n                        return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n                    }\n                } else if (closingTag) {\n                    if (!result.tagClosed) {\n                        return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n                    } else if (attrStr.trim().length > 0) {\n                        return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n                    } else if (tags.length === 0) {\n                        return getErrorObject(\"InvalidTag\", \"Closing tag '\" + tagName + \"' has not been opened.\", getLineNumberForPosition(xmlData, tagStartPos));\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg.tagName) {\n                            let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n                            return getErrorObject(\"InvalidTag\", \"Expected closing tag '\" + otg.tagName + \"' (opened in line \" + openPos.line + \", col \" + openPos.col + \") instead of closing tag '\" + tagName + \"'.\", getLineNumberForPosition(xmlData, tagStartPos));\n                        }\n                        //when there are no more tags, we reached the root level.\n                        if (tags.length == 0) {\n                            reachedRoot = true;\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options);\n                    if (isValid !== true) {\n                        //the result from the nested function returns the position of the error within the attribute\n                        //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n                        //this gives us the absolute index in the entire xml, which we can use to find the line at last\n                        return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n                    }\n                    //if the root level has been reached before ...\n                    if (reachedRoot === true) {\n                        return getErrorObject(\"InvalidXml\", \"Multiple possible root nodes found.\", getLineNumberForPosition(xmlData, i));\n                    } else if (options.unpairedTags.indexOf(tagName) !== -1) {\n                    //don't push into stack\n                    } else {\n                        tags.push({\n                            tagName,\n                            tagStartPos\n                        });\n                    }\n                    tagFound = true;\n                }\n                //skip tag text value\n                //It may include comments and CDATA value\n                for(i++; i < xmlData.length; i++){\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {\n                            //comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else if (xmlData[i + 1] === \"?\") {\n                            i = readPI(xmlData, ++i);\n                            if (i.err) return i;\n                        } else {\n                            break;\n                        }\n                    } else if (xmlData[i] === \"&\") {\n                        const afterAmp = validateAmpersand(xmlData, i);\n                        if (afterAmp == -1) return getErrorObject(\"InvalidChar\", \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n                        i = afterAmp;\n                    } else {\n                        if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n                            return getErrorObject(\"InvalidXml\", \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n                        }\n                    }\n                } //end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (isWhiteSpace(xmlData[i])) {\n                continue;\n            }\n            return getErrorObject(\"InvalidChar\", \"char '\" + xmlData[i] + \"' is not expected.\", getLineNumberForPosition(xmlData, i));\n        }\n    }\n    if (!tagFound) {\n        return getErrorObject(\"InvalidXml\", \"Start tag expected.\", 1);\n    } else if (tags.length == 1) {\n        return getErrorObject(\"InvalidTag\", \"Unclosed tag '\" + tags[0].tagName + \"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n    } else if (tags.length > 0) {\n        return getErrorObject(\"InvalidXml\", \"Invalid '\" + JSON.stringify(tags.map((t)=>t.tagName), null, 4).replace(/\\r?\\n/g, \"\") + \"' found.\", {\n            line: 1,\n            col: 1\n        });\n    }\n    return true;\n}\n;\nfunction isWhiteSpace(char) {\n    return char === \" \" || char === \"\t\" || char === \"\\n\" || char === \"\\r\";\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */ function readPI(xmlData, i) {\n    const start = i;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] == \"?\" || xmlData[i] == \" \") {\n            //tagname\n            const tagname = xmlData.substr(start, i - start);\n            if (i > 5 && tagname === \"xml\") {\n                return getErrorObject(\"InvalidXml\", \"XML declaration allowed only at the start of the document.\", getLineNumberForPosition(xmlData, i));\n            } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n                //check if valid attribut string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {\n        //comment\n        for(i += 3; i < xmlData.length; i++){\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 && xmlData[i + 1] === \"D\" && xmlData[i + 2] === \"O\" && xmlData[i + 3] === \"C\" && xmlData[i + 4] === \"T\" && xmlData[i + 5] === \"Y\" && xmlData[i + 6] === \"P\" && xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for(i += 8; i < xmlData.length; i++){\n            if (xmlData[i] === \"<\") {\n                angleBracketsCount++;\n            } else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 && xmlData[i + 1] === \"[\" && xmlData[i + 2] === \"C\" && xmlData[i + 3] === \"D\" && xmlData[i + 4] === \"A\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"A\" && xmlData[i + 7] === \"[\") {\n        for(i += 8; i < xmlData.length; i++){\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n    return i;\n}\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */ function readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    let tagClosed = false;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n            //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                tagClosed = true;\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n    return {\n        value: attrStr,\n        index: i,\n        tagClosed: tagClosed\n    };\n}\n/**\n * Select all the attributes whether valid or invalid.\n */ const validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\nfunction validateAttributeString(attrStr, options) {\n    //console.log(\"start:\"+attrStr+\":end\");\n    //if(attrStr.trim().length === 0) return true; //empty string\n    const matches = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.getAllMatches)(attrStr, validAttrStrRegxp);\n    const attrNames = {};\n    for(let i = 0; i < matches.length; i++){\n        if (matches[i][1].length === 0) {\n            //nospace before attribute name: a=\"sd\"b=\"saf\"\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' has no space in starting.\", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + matches[i][2] + \"' is without value.\", getPositionFromMatch(matches[i]));\n        } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n            //independent attribute: ab\n            return getErrorObject(\"InvalidAttr\", \"boolean attribute '\" + matches[i][2] + \"' is not allowed.\", getPositionFromMatch(matches[i]));\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */ const attrName = matches[i][2];\n        if (!validateAttrName(attrName)) {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is an invalid name.\", getPositionFromMatch(matches[i]));\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {\n            //check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return getErrorObject(\"InvalidAttr\", \"Attribute '\" + attrName + \"' is repeated.\", getPositionFromMatch(matches[i]));\n        }\n    }\n    return true;\n}\nfunction validateNumberAmpersand(xmlData, i) {\n    let re = /\\d/;\n    if (xmlData[i] === \"x\") {\n        i++;\n        re = /[\\da-fA-F]/;\n    }\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === \";\") return i;\n        if (!xmlData[i].match(re)) break;\n    }\n    return -1;\n}\nfunction validateAmpersand(xmlData, i) {\n    // https://www.w3.org/TR/xml/#dt-charref\n    i++;\n    if (xmlData[i] === \";\") return -1;\n    if (xmlData[i] === \"#\") {\n        i++;\n        return validateNumberAmpersand(xmlData, i);\n    }\n    let count = 0;\n    for(; i < xmlData.length; i++, count++){\n        if (xmlData[i].match(/\\w/) && count < 20) continue;\n        if (xmlData[i] === \";\") break;\n        return -1;\n    }\n    return i;\n}\nfunction getErrorObject(code, message, lineNumber) {\n    return {\n        err: {\n            code: code,\n            msg: message,\n            line: lineNumber.line || lineNumber,\n            col: lineNumber.col\n        }\n    };\n}\nfunction validateAttrName(attrName) {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isName)(attrName);\n}\n// const startsWithXML = /^xml/i;\nfunction validateTagName(tagname) {\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isName)(tagname) /* && !tagname.match(startsWithXML) */ ;\n}\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n    const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n    return {\n        line: lines.length,\n        // column number is last line's length + 1, because column numbering starts at 1:\n        col: lines[lines.length - 1].length + 1\n    };\n}\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n    return match.startIndex + match[1].length;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMvdmFsaWRhdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFFZ0Q7QUFFaEQsTUFBTUUsaUJBQWlCO0lBQ3JCQyx3QkFBd0I7SUFDeEJDLGNBQWMsRUFBRTtBQUNsQjtBQUVBLHFFQUFxRTtBQUM5RCxTQUFTQyxTQUFTQyxPQUFPLEVBQUVDLE9BQU87SUFDdkNBLFVBQVVDLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdQLGdCQUFnQks7SUFFNUMsc0VBQXNFO0lBQ3RFLCtFQUErRTtJQUMvRSw2RkFBNkY7SUFDN0YsTUFBTUcsT0FBTyxFQUFFO0lBQ2YsSUFBSUMsV0FBVztJQUVmLDZFQUE2RTtJQUM3RSxJQUFJQyxjQUFjO0lBRWxCLElBQUlOLE9BQU8sQ0FBQyxFQUFFLEtBQUssVUFBVTtRQUMzQixrQ0FBa0M7UUFDbENBLFVBQVVBLFFBQVFPLE1BQU0sQ0FBQztJQUMzQjtJQUVBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJUixRQUFRUyxNQUFNLEVBQUVELElBQUs7UUFFdkMsSUFBSVIsT0FBTyxDQUFDUSxFQUFFLEtBQUssT0FBT1IsT0FBTyxDQUFDUSxJQUFFLEVBQUUsS0FBSyxLQUFLO1lBQzlDQSxLQUFHO1lBQ0hBLElBQUlFLE9BQU9WLFNBQVFRO1lBQ25CLElBQUlBLEVBQUVHLEdBQUcsRUFBRSxPQUFPSDtRQUNwQixPQUFNLElBQUlSLE9BQU8sQ0FBQ1EsRUFBRSxLQUFLLEtBQUs7WUFDNUIsaUJBQWlCO1lBQ2pCLGlFQUFpRTtZQUNqRSxJQUFJSSxjQUFjSjtZQUNsQkE7WUFFQSxJQUFJUixPQUFPLENBQUNRLEVBQUUsS0FBSyxLQUFLO2dCQUN0QkEsSUFBSUssb0JBQW9CYixTQUFTUTtnQkFDakM7WUFDRixPQUFPO2dCQUNMLElBQUlNLGFBQWE7Z0JBQ2pCLElBQUlkLE9BQU8sQ0FBQ1EsRUFBRSxLQUFLLEtBQUs7b0JBQ3RCLGFBQWE7b0JBQ2JNLGFBQWE7b0JB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QUN6QmhDLEtBQUtnQyxXQUFXaEMsR0FBRztRQUNyQjtJQUNGO0FBQ0Y7QUFFQSxTQUFTeUIsaUJBQWlCRCxRQUFRO0lBQ2hDLE9BQU9qRSxnREFBTUEsQ0FBQ2lFO0FBQ2hCO0FBRUEsaUNBQWlDO0FBRWpDLFNBQVMxQyxnQkFBZ0IrQixPQUFPO0lBQzlCLE9BQU90RCxnREFBTUEsQ0FBQ3NELFNBQVMsb0NBQW9DO0FBQzdEO0FBRUEsNEVBQTRFO0FBQzVFLFNBQVM1Qix5QkFBeUJyQixPQUFPLEVBQUUwQixLQUFLO0lBQzlDLE1BQU0yQyxRQUFRckUsUUFBUWlCLFNBQVMsQ0FBQyxHQUFHUyxPQUFPNEMsS0FBSyxDQUFDO0lBQ2hELE9BQU87UUFDTHZDLE1BQU1zQyxNQUFNNUQsTUFBTTtRQUVsQixpRkFBaUY7UUFDakYyQixLQUFLaUMsS0FBSyxDQUFDQSxNQUFNNUQsTUFBTSxHQUFHLEVBQUUsQ0FBQ0EsTUFBTSxHQUFHO0lBQ3hDO0FBQ0Y7QUFFQSxtRkFBbUY7QUFDbkYsU0FBU2lELHFCQUFxQk8sS0FBSztJQUNqQyxPQUFPQSxNQUFNTSxVQUFVLEdBQUdOLEtBQUssQ0FBQyxFQUFFLENBQUN4RCxNQUFNO0FBQzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FsZXMtZGFzaGJvYXJkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3ZhbGlkYXRvci5qcz8wNzc0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtnZXRBbGxNYXRjaGVzLCBpc05hbWV9IGZyb20gJy4vdXRpbC5qcyc7XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBhbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzOiBmYWxzZSwgLy9BIHRhZyBjYW4gaGF2ZSBhdHRyaWJ1dGVzIHdpdGhvdXQgYW55IHZhbHVlXG4gIHVucGFpcmVkVGFnczogW11cbn07XG5cbi8vY29uc3QgdGFnc1BhdHRlcm4gPSBuZXcgUmVnRXhwKFwiPFxcXFwvPyhbXFxcXHc6XFxcXC1fXFwuXSspXFxcXHMqXFwvPz5cIixcImdcIik7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoeG1sRGF0YSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gIC8veG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvKFxcclxcbnxcXG58XFxyKS9nbSxcIlwiKTsvL21ha2UgaXQgc2luZ2xlIGxpbmVcbiAgLy94bWxEYXRhID0geG1sRGF0YS5yZXBsYWNlKC8oXlxccyo8XFw/eG1sLio/XFw/PikvZyxcIlwiKTsvL1JlbW92ZSBYTUwgc3RhcnRpbmcgdGFnXG4gIC8veG1sRGF0YSA9IHhtbERhdGEucmVwbGFjZSgvKDwhRE9DVFlQRVtcXHNcXHdcXFwiXFwuXFwvXFwtXFw6XSsoXFxbLipcXF0pKlxccyo+KS9nLFwiXCIpOy8vUmVtb3ZlIERPQ1RZUEVcbiAgY29uc3QgdGFncyA9IFtdO1xuICBsZXQgdGFnRm91bmQgPSBmYWxzZTtcblxuICAvL2luZGljYXRlcyB0aGF0IHRoZSByb290IHRhZyBoYXMgYmVlbiBjbG9zZWQgKGFrYS4gZGVwdGggMCBoYXMgYmVlbiByZWFjaGVkKVxuICBsZXQgcmVhY2hlZFJvb3QgPSBmYWxzZTtcblxuICBpZiAoeG1sRGF0YVswXSA9PT0gJ1xcdWZlZmYnKSB7XG4gICAgLy8gY2hlY2sgZm9yIGJ5dGUgb3JkZXIgbWFyayAoQk9NKVxuICAgIHhtbERhdGEgPSB4bWxEYXRhLnN1YnN0cigxKTtcbiAgfVxuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnICYmIHhtbERhdGFbaSsxXSA9PT0gJz8nKSB7XG4gICAgICBpKz0yO1xuICAgICAgaSA9IHJlYWRQSSh4bWxEYXRhLGkpO1xuICAgICAgaWYgKGkuZXJyKSByZXR1cm4gaTtcbiAgICB9ZWxzZSBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnKSB7XG4gICAgICAvL3N0YXJ0aW5nIG9mIHRhZ1xuICAgICAgLy9yZWFkIHVudGlsIHlvdSByZWFjaCB0byAnPicgYXZvaWRpbmcgYW55ICc+JyBpbiBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgIGxldCB0YWdTdGFydFBvcyA9IGk7XG4gICAgICBpKys7XG4gICAgICBcbiAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnIScpIHtcbiAgICAgICAgaSA9IHJlYWRDb21tZW50QW5kQ0RBVEEoeG1sRGF0YSwgaSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNsb3NpbmdUYWcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICcvJykge1xuICAgICAgICAgIC8vY2xvc2luZyB0YWdcbiAgICAgICAgICBjbG9zaW5nVGFnID0gdHJ1ZTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZWFkIHRhZ25hbWVcbiAgICAgICAgbGV0IHRhZ05hbWUgPSAnJztcbiAgICAgICAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aCAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICc+JyAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICcgJyAmJlxuICAgICAgICAgIHhtbERhdGFbaV0gIT09ICdcXHQnICYmXG4gICAgICAgICAgeG1sRGF0YVtpXSAhPT0gJ1xcbicgJiZcbiAgICAgICAgICB4bWxEYXRhW2ldICE9PSAnXFxyJzsgaSsrXG4gICAgICAgICkge1xuICAgICAgICAgIHRhZ05hbWUgKz0geG1sRGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS50cmltKCk7XG4gICAgICAgIC8vY29uc29sZS5sb2codGFnTmFtZSk7XG5cbiAgICAgICAgaWYgKHRhZ05hbWVbdGFnTmFtZS5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy9zZWxmIGNsb3NpbmcgdGFnIHdpdGhvdXQgYXR0cmlidXRlc1xuICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnN1YnN0cmluZygwLCB0YWdOYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIC8vY29udGludWU7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsaWRhdGVUYWdOYW1lKHRhZ05hbWUpKSB7XG4gICAgICAgICAgbGV0IG1zZztcbiAgICAgICAgICBpZiAodGFnTmFtZS50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtc2cgPSBcIkludmFsaWQgc3BhY2UgYWZ0ZXIgJzwnLlwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtc2cgPSBcIlRhZyAnXCIrdGFnTmFtZStcIicgaXMgYW4gaW52YWxpZCBuYW1lLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRUYWcnLCBtc2csIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkQXR0cmlidXRlU3RyKHhtbERhdGEsIGkpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZEF0dHInLCBcIkF0dHJpYnV0ZXMgZm9yICdcIit0YWdOYW1lK1wiJyBoYXZlIG9wZW4gcXVvdGUuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF0dHJTdHIgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGkgPSByZXN1bHQuaW5kZXg7XG5cbiAgICAgICAgaWYgKGF0dHJTdHJbYXR0clN0ci5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgLy9zZWxmIGNsb3NpbmcgdGFnXG4gICAgICAgICAgY29uc3QgYXR0clN0clN0YXJ0ID0gaSAtIGF0dHJTdHIubGVuZ3RoO1xuICAgICAgICAgIGF0dHJTdHIgPSBhdHRyU3RyLnN1YnN0cmluZygwLCBhdHRyU3RyLmxlbmd0aCAtIDEpO1xuICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSB2YWxpZGF0ZUF0dHJpYnV0ZVN0cmluZyhhdHRyU3RyLCBvcHRpb25zKTtcbiAgICAgICAgICBpZiAoaXNWYWxpZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGFnRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgLy9jb250aW51ZTsgLy90ZXh0IG1heSBwcmVzZW50cyBhZnRlciBzZWxmIGNsb3NpbmcgdGFnXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vdGhlIHJlc3VsdCBmcm9tIHRoZSBuZXN0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGVycm9yIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL2luIG9yZGVyIHRvIGdldCB0aGUgJ3RydWUnIGVycm9yIGxpbmUsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgYXR0cmlidXRlIGJlZ2lucyAoaSAtIGF0dHJTdHIubGVuZ3RoKSBhbmQgdGhlbiBhZGQgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL3RoaXMgZ2l2ZXMgdXMgdGhlIGFic29sdXRlIGluZGV4IGluIHRoZSBlbnRpcmUgeG1sLCB3aGljaCB3ZSBjYW4gdXNlIHRvIGZpbmQgdGhlIGxpbmUgYXQgbGFzdFxuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KGlzVmFsaWQuZXJyLmNvZGUsIGlzVmFsaWQuZXJyLm1zZywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGF0dHJTdHJTdGFydCArIGlzVmFsaWQuZXJyLmxpbmUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2xvc2luZ1RhZykge1xuICAgICAgICAgIGlmICghcmVzdWx0LnRhZ0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgXCJDbG9zaW5nIHRhZyAnXCIrdGFnTmFtZStcIicgZG9lc24ndCBoYXZlIHByb3BlciBjbG9zaW5nLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXR0clN0ci50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgXCJDbG9zaW5nIHRhZyAnXCIrdGFnTmFtZStcIicgY2FuJ3QgaGF2ZSBhdHRyaWJ1dGVzIG9yIGludmFsaWQgc3RhcnRpbmcuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCB0YWdTdGFydFBvcykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsIFwiQ2xvc2luZyB0YWcgJ1wiK3RhZ05hbWUrXCInIGhhcyBub3QgYmVlbiBvcGVuZWQuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCB0YWdTdGFydFBvcykpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvdGcgPSB0YWdzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHRhZ05hbWUgIT09IG90Zy50YWdOYW1lKSB7XG4gICAgICAgICAgICAgIGxldCBvcGVuUG9zID0gZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIG90Zy50YWdTdGFydFBvcyk7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFRhZycsXG4gICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBjbG9zaW5nIHRhZyAnXCIrb3RnLnRhZ05hbWUrXCInIChvcGVuZWQgaW4gbGluZSBcIitvcGVuUG9zLmxpbmUrXCIsIGNvbCBcIitvcGVuUG9zLmNvbCtcIikgaW5zdGVhZCBvZiBjbG9zaW5nIHRhZyAnXCIrdGFnTmFtZStcIicuXCIsXG4gICAgICAgICAgICAgICAgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIHRhZ1N0YXJ0UG9zKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vd2hlbiB0aGVyZSBhcmUgbm8gbW9yZSB0YWdzLCB3ZSByZWFjaGVkIHRoZSByb290IGxldmVsLlxuICAgICAgICAgICAgaWYgKHRhZ3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgcmVhY2hlZFJvb3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gdmFsaWRhdGVBdHRyaWJ1dGVTdHJpbmcoYXR0clN0ciwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKGlzVmFsaWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vdGhlIHJlc3VsdCBmcm9tIHRoZSBuZXN0ZWQgZnVuY3Rpb24gcmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGVycm9yIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL2luIG9yZGVyIHRvIGdldCB0aGUgJ3RydWUnIGVycm9yIGxpbmUsIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgYXR0cmlidXRlIGJlZ2lucyAoaSAtIGF0dHJTdHIubGVuZ3RoKSBhbmQgdGhlbiBhZGQgdGhlIHBvc2l0aW9uIHdpdGhpbiB0aGUgYXR0cmlidXRlXG4gICAgICAgICAgICAvL3RoaXMgZ2l2ZXMgdXMgdGhlIGFic29sdXRlIGluZGV4IGluIHRoZSBlbnRpcmUgeG1sLCB3aGljaCB3ZSBjYW4gdXNlIHRvIGZpbmQgdGhlIGxpbmUgYXQgbGFzdFxuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KGlzVmFsaWQuZXJyLmNvZGUsIGlzVmFsaWQuZXJyLm1zZywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkgLSBhdHRyU3RyLmxlbmd0aCArIGlzVmFsaWQuZXJyLmxpbmUpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL2lmIHRoZSByb290IGxldmVsIGhhcyBiZWVuIHJlYWNoZWQgYmVmb3JlIC4uLlxuICAgICAgICAgIGlmIChyZWFjaGVkUm9vdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgJ011bHRpcGxlIHBvc3NpYmxlIHJvb3Qgbm9kZXMgZm91bmQuJywgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgICB9IGVsc2UgaWYob3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZih0YWdOYW1lKSAhPT0gLTEpe1xuICAgICAgICAgICAgLy9kb24ndCBwdXNoIGludG8gc3RhY2tcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFncy5wdXNoKHt0YWdOYW1lLCB0YWdTdGFydFBvc30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWdGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvL3NraXAgdGFnIHRleHQgdmFsdWVcbiAgICAgICAgLy9JdCBtYXkgaW5jbHVkZSBjb21tZW50cyBhbmQgQ0RBVEEgdmFsdWVcbiAgICAgICAgZm9yIChpKys7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICc8Jykge1xuICAgICAgICAgICAgaWYgKHhtbERhdGFbaSArIDFdID09PSAnIScpIHtcbiAgICAgICAgICAgICAgLy9jb21tZW50IG9yIENBREFUQVxuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIGkgPSByZWFkQ29tbWVudEFuZENEQVRBKHhtbERhdGEsIGkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeG1sRGF0YVtpKzFdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgaSA9IHJlYWRQSSh4bWxEYXRhLCArK2kpO1xuICAgICAgICAgICAgICBpZiAoaS5lcnIpIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICcmJykge1xuICAgICAgICAgICAgY29uc3QgYWZ0ZXJBbXAgPSB2YWxpZGF0ZUFtcGVyc2FuZCh4bWxEYXRhLCBpKTtcbiAgICAgICAgICAgIGlmIChhZnRlckFtcCA9PSAtMSlcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQ2hhcicsIFwiY2hhciAnJicgaXMgbm90IGV4cGVjdGVkLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgICAgICAgICAgaSA9IGFmdGVyQW1wO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgaWYgKHJlYWNoZWRSb290ID09PSB0cnVlICYmICFpc1doaXRlU3BhY2UoeG1sRGF0YVtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkWG1sJywgXCJFeHRyYSB0ZXh0IGF0IHRoZSBlbmRcIiwgZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy9lbmQgb2YgcmVhZGluZyB0YWcgdGV4dCB2YWx1ZVxuICAgICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzwnKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICggaXNXaGl0ZVNwYWNlKHhtbERhdGFbaV0pKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQ2hhcicsIFwiY2hhciAnXCIreG1sRGF0YVtpXStcIicgaXMgbm90IGV4cGVjdGVkLlwiLCBnZXRMaW5lTnVtYmVyRm9yUG9zaXRpb24oeG1sRGF0YSwgaSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGFnRm91bmQpIHtcbiAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRYbWwnLCAnU3RhcnQgdGFnIGV4cGVjdGVkLicsIDEpO1xuICB9ZWxzZSBpZiAodGFncy5sZW5ndGggPT0gMSkge1xuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkVGFnJywgXCJVbmNsb3NlZCB0YWcgJ1wiK3RhZ3NbMF0udGFnTmFtZStcIicuXCIsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCB0YWdzWzBdLnRhZ1N0YXJ0UG9zKSk7XG4gIH1lbHNlIGlmICh0YWdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBnZXRFcnJvck9iamVjdCgnSW52YWxpZFhtbCcsIFwiSW52YWxpZCAnXCIrXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkodGFncy5tYXAodCA9PiB0LnRhZ05hbWUpLCBudWxsLCA0KS5yZXBsYWNlKC9cXHI/XFxuL2csICcnKStcbiAgICAgICAgICBcIicgZm91bmQuXCIsIHtsaW5lOiAxLCBjb2w6IDF9KTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoYXIpe1xuICByZXR1cm4gY2hhciA9PT0gJyAnIHx8IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICdcXG4nICB8fCBjaGFyID09PSAnXFxyJztcbn1cbi8qKlxuICogUmVhZCBQcm9jZXNzaW5nIGluc3N0cnVjdGlvbnMgYW5kIHNraXBcbiAqIEBwYXJhbSB7Kn0geG1sRGF0YVxuICogQHBhcmFtIHsqfSBpXG4gKi9cbmZ1bmN0aW9uIHJlYWRQSSh4bWxEYXRhLCBpKSB7XG4gIGNvbnN0IHN0YXJ0ID0gaTtcbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHhtbERhdGFbaV0gPT0gJz8nIHx8IHhtbERhdGFbaV0gPT0gJyAnKSB7XG4gICAgICAvL3RhZ25hbWVcbiAgICAgIGNvbnN0IHRhZ25hbWUgPSB4bWxEYXRhLnN1YnN0cihzdGFydCwgaSAtIHN0YXJ0KTtcbiAgICAgIGlmIChpID4gNSAmJiB0YWduYW1lID09PSAneG1sJykge1xuICAgICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRYbWwnLCAnWE1MIGRlY2xhcmF0aW9uIGFsbG93ZWQgb25seSBhdCB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50LicsIGdldExpbmVOdW1iZXJGb3JQb3NpdGlvbih4bWxEYXRhLCBpKSk7XG4gICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT0gJz8nICYmIHhtbERhdGFbaSArIDFdID09ICc+Jykge1xuICAgICAgICAvL2NoZWNrIGlmIHZhbGlkIGF0dHJpYnV0IHN0cmluZ1xuICAgICAgICBpKys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiByZWFkQ29tbWVudEFuZENEQVRBKHhtbERhdGEsIGkpIHtcbiAgaWYgKHhtbERhdGEubGVuZ3RoID4gaSArIDUgJiYgeG1sRGF0YVtpICsgMV0gPT09ICctJyAmJiB4bWxEYXRhW2kgKyAyXSA9PT0gJy0nKSB7XG4gICAgLy9jb21tZW50XG4gICAgZm9yIChpICs9IDM7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJy0nICYmIHhtbERhdGFbaSArIDFdID09PSAnLScgJiYgeG1sRGF0YVtpICsgMl0gPT09ICc+Jykge1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChcbiAgICB4bWxEYXRhLmxlbmd0aCA+IGkgKyA4ICYmXG4gICAgeG1sRGF0YVtpICsgMV0gPT09ICdEJyAmJlxuICAgIHhtbERhdGFbaSArIDJdID09PSAnTycgJiZcbiAgICB4bWxEYXRhW2kgKyAzXSA9PT0gJ0MnICYmXG4gICAgeG1sRGF0YVtpICsgNF0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSArIDVdID09PSAnWScgJiZcbiAgICB4bWxEYXRhW2kgKyA2XSA9PT0gJ1AnICYmXG4gICAgeG1sRGF0YVtpICsgN10gPT09ICdFJ1xuICApIHtcbiAgICBsZXQgYW5nbGVCcmFja2V0c0NvdW50ID0gMTtcbiAgICBmb3IgKGkgKz0gODsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnPCcpIHtcbiAgICAgICAgYW5nbGVCcmFja2V0c0NvdW50Kys7XG4gICAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICc+Jykge1xuICAgICAgICBhbmdsZUJyYWNrZXRzQ291bnQtLTtcbiAgICAgICAgaWYgKGFuZ2xlQnJhY2tldHNDb3VudCA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFxuICAgIHhtbERhdGEubGVuZ3RoID4gaSArIDkgJiZcbiAgICB4bWxEYXRhW2kgKyAxXSA9PT0gJ1snICYmXG4gICAgeG1sRGF0YVtpICsgMl0gPT09ICdDJyAmJlxuICAgIHhtbERhdGFbaSArIDNdID09PSAnRCcgJiZcbiAgICB4bWxEYXRhW2kgKyA0XSA9PT0gJ0EnICYmXG4gICAgeG1sRGF0YVtpICsgNV0gPT09ICdUJyAmJlxuICAgIHhtbERhdGFbaSArIDZdID09PSAnQScgJiZcbiAgICB4bWxEYXRhW2kgKyA3XSA9PT0gJ1snXG4gICkge1xuICAgIGZvciAoaSArPSA4OyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHhtbERhdGFbaV0gPT09ICddJyAmJiB4bWxEYXRhW2kgKyAxXSA9PT0gJ10nICYmIHhtbERhdGFbaSArIDJdID09PSAnPicpIHtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaTtcbn1cblxuY29uc3QgZG91YmxlUXVvdGUgPSAnXCInO1xuY29uc3Qgc2luZ2xlUXVvdGUgPSBcIidcIjtcblxuLyoqXG4gKiBLZWVwIHJlYWRpbmcgeG1sRGF0YSB1bnRpbCAnPCcgaXMgZm91bmQgb3V0c2lkZSB0aGUgYXR0cmlidXRlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IHhtbERhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKi9cbmZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGVTdHIoeG1sRGF0YSwgaSkge1xuICBsZXQgYXR0clN0ciA9ICcnO1xuICBsZXQgc3RhcnRDaGFyID0gJyc7XG4gIGxldCB0YWdDbG9zZWQgPSBmYWxzZTtcbiAgZm9yICg7IGkgPCB4bWxEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHhtbERhdGFbaV0gPT09IGRvdWJsZVF1b3RlIHx8IHhtbERhdGFbaV0gPT09IHNpbmdsZVF1b3RlKSB7XG4gICAgICBpZiAoc3RhcnRDaGFyID09PSAnJykge1xuICAgICAgICBzdGFydENoYXIgPSB4bWxEYXRhW2ldO1xuICAgICAgfSBlbHNlIGlmIChzdGFydENoYXIgIT09IHhtbERhdGFbaV0pIHtcbiAgICAgICAgLy9pZiB2YXVlIGlzIGVuY2xvc2VkIHdpdGggZG91YmxlIHF1b3RlIHRoZW4gc2luZ2xlIHF1b3RlcyBhcmUgYWxsb3dlZCBpbnNpZGUgdGhlIHZhbHVlIGFuZCB2aWNlIHZlcnNhXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydENoYXIgPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHhtbERhdGFbaV0gPT09ICc+Jykge1xuICAgICAgaWYgKHN0YXJ0Q2hhciA9PT0gJycpIHtcbiAgICAgICAgdGFnQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGF0dHJTdHIgKz0geG1sRGF0YVtpXTtcbiAgfVxuICBpZiAoc3RhcnRDaGFyICE9PSAnJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdmFsdWU6IGF0dHJTdHIsXG4gICAgaW5kZXg6IGksXG4gICAgdGFnQ2xvc2VkOiB0YWdDbG9zZWRcbiAgfTtcbn1cblxuLyoqXG4gKiBTZWxlY3QgYWxsIHRoZSBhdHRyaWJ1dGVzIHdoZXRoZXIgdmFsaWQgb3IgaW52YWxpZC5cbiAqL1xuY29uc3QgdmFsaWRBdHRyU3RyUmVneHAgPSBuZXcgUmVnRXhwKCcoXFxcXHMqKShbXlxcXFxzPV0rKShcXFxccyo9KT8oXFxcXHMqKFtcXCdcIl0pKChbXFxcXHNcXFxcU10pKj8pXFxcXDUpPycsICdnJyk7XG5cbi8vYXR0ciwgPVwic2RcIiwgYT1cImFtaXQnc1wiLCBhPVwic2RcImI9XCJzYWZcIiwgYWIgIGNkPVwiXCJcblxuZnVuY3Rpb24gdmFsaWRhdGVBdHRyaWJ1dGVTdHJpbmcoYXR0clN0ciwgb3B0aW9ucykge1xuICAvL2NvbnNvbGUubG9nKFwic3RhcnQ6XCIrYXR0clN0citcIjplbmRcIik7XG5cbiAgLy9pZihhdHRyU3RyLnRyaW0oKS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlOyAvL2VtcHR5IHN0cmluZ1xuXG4gIGNvbnN0IG1hdGNoZXMgPSBnZXRBbGxNYXRjaGVzKGF0dHJTdHIsIHZhbGlkQXR0clN0clJlZ3hwKTtcbiAgY29uc3QgYXR0ck5hbWVzID0ge307XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1hdGNoZXNbaV1bMV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAvL25vc3BhY2UgYmVmb3JlIGF0dHJpYnV0ZSBuYW1lOiBhPVwic2RcImI9XCJzYWZcIlxuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiQXR0cmlidXRlICdcIittYXRjaGVzW2ldWzJdK1wiJyBoYXMgbm8gc3BhY2UgaW4gc3RhcnRpbmcuXCIsIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoZXNbaV0pKVxuICAgIH0gZWxzZSBpZiAobWF0Y2hlc1tpXVszXSAhPT0gdW5kZWZpbmVkICYmIG1hdGNoZXNbaV1bNF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiQXR0cmlidXRlICdcIittYXRjaGVzW2ldWzJdK1wiJyBpcyB3aXRob3V0IHZhbHVlLlwiLCBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaGVzW2ldKSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaGVzW2ldWzNdID09PSB1bmRlZmluZWQgJiYgIW9wdGlvbnMuYWxsb3dCb29sZWFuQXR0cmlidXRlcykge1xuICAgICAgLy9pbmRlcGVuZGVudCBhdHRyaWJ1dGU6IGFiXG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJib29sZWFuIGF0dHJpYnV0ZSAnXCIrbWF0Y2hlc1tpXVsyXStcIicgaXMgbm90IGFsbG93ZWQuXCIsIGdldFBvc2l0aW9uRnJvbU1hdGNoKG1hdGNoZXNbaV0pKTtcbiAgICB9XG4gICAgLyogZWxzZSBpZihtYXRjaGVzW2ldWzZdID09PSB1bmRlZmluZWQpey8vYXR0cmlidXRlIHdpdGhvdXQgdmFsdWU6IGFiPVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnI6IHsgY29kZTpcIkludmFsaWRBdHRyXCIsbXNnOlwiYXR0cmlidXRlIFwiICsgbWF0Y2hlc1tpXVsyXSArIFwiIGhhcyBubyB2YWx1ZSBhc3NpZ25lZC5cIn19O1xuICAgICAgICAgICAgICAgIH0gKi9cbiAgICBjb25zdCBhdHRyTmFtZSA9IG1hdGNoZXNbaV1bMl07XG4gICAgaWYgKCF2YWxpZGF0ZUF0dHJOYW1lKGF0dHJOYW1lKSkge1xuICAgICAgcmV0dXJuIGdldEVycm9yT2JqZWN0KCdJbnZhbGlkQXR0cicsIFwiQXR0cmlidXRlICdcIithdHRyTmFtZStcIicgaXMgYW4gaW52YWxpZCBuYW1lLlwiLCBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaGVzW2ldKSk7XG4gICAgfVxuICAgIGlmICghYXR0ck5hbWVzLmhhc093blByb3BlcnR5KGF0dHJOYW1lKSkge1xuICAgICAgLy9jaGVjayBmb3IgZHVwbGljYXRlIGF0dHJpYnV0ZS5cbiAgICAgIGF0dHJOYW1lc1thdHRyTmFtZV0gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0RXJyb3JPYmplY3QoJ0ludmFsaWRBdHRyJywgXCJBdHRyaWJ1dGUgJ1wiK2F0dHJOYW1lK1wiJyBpcyByZXBlYXRlZC5cIiwgZ2V0UG9zaXRpb25Gcm9tTWF0Y2gobWF0Y2hlc1tpXSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlckFtcGVyc2FuZCh4bWxEYXRhLCBpKSB7XG4gIGxldCByZSA9IC9cXGQvO1xuICBpZiAoeG1sRGF0YVtpXSA9PT0gJ3gnKSB7XG4gICAgaSsrO1xuICAgIHJlID0gL1tcXGRhLWZBLUZdLztcbiAgfVxuICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJzsnKVxuICAgICAgcmV0dXJuIGk7XG4gICAgaWYgKCF4bWxEYXRhW2ldLm1hdGNoKHJlKSlcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBbXBlcnNhbmQoeG1sRGF0YSwgaSkge1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIveG1sLyNkdC1jaGFycmVmXG4gIGkrKztcbiAgaWYgKHhtbERhdGFbaV0gPT09ICc7JylcbiAgICByZXR1cm4gLTE7XG4gIGlmICh4bWxEYXRhW2ldID09PSAnIycpIHtcbiAgICBpKys7XG4gICAgcmV0dXJuIHZhbGlkYXRlTnVtYmVyQW1wZXJzYW5kKHhtbERhdGEsIGkpO1xuICB9XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAoOyBpIDwgeG1sRGF0YS5sZW5ndGg7IGkrKywgY291bnQrKykge1xuICAgIGlmICh4bWxEYXRhW2ldLm1hdGNoKC9cXHcvKSAmJiBjb3VudCA8IDIwKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHhtbERhdGFbaV0gPT09ICc7JylcbiAgICAgIGJyZWFrO1xuICAgIHJldHVybiAtMTtcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gZ2V0RXJyb3JPYmplY3QoY29kZSwgbWVzc2FnZSwgbGluZU51bWJlcikge1xuICByZXR1cm4ge1xuICAgIGVycjoge1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIG1zZzogbWVzc2FnZSxcbiAgICAgIGxpbmU6IGxpbmVOdW1iZXIubGluZSB8fCBsaW5lTnVtYmVyLFxuICAgICAgY29sOiBsaW5lTnVtYmVyLmNvbCxcbiAgICB9LFxuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUF0dHJOYW1lKGF0dHJOYW1lKSB7XG4gIHJldHVybiBpc05hbWUoYXR0ck5hbWUpO1xufVxuXG4vLyBjb25zdCBzdGFydHNXaXRoWE1MID0gL154bWwvaTtcblxuZnVuY3Rpb24gdmFsaWRhdGVUYWdOYW1lKHRhZ25hbWUpIHtcbiAgcmV0dXJuIGlzTmFtZSh0YWduYW1lKSAvKiAmJiAhdGFnbmFtZS5tYXRjaChzdGFydHNXaXRoWE1MKSAqLztcbn1cblxuLy90aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGxpbmUgbnVtYmVyIGZvciB0aGUgY2hhcmFjdGVyIGF0IHRoZSBnaXZlbiBpbmRleFxuZnVuY3Rpb24gZ2V0TGluZU51bWJlckZvclBvc2l0aW9uKHhtbERhdGEsIGluZGV4KSB7XG4gIGNvbnN0IGxpbmVzID0geG1sRGF0YS5zdWJzdHJpbmcoMCwgaW5kZXgpLnNwbGl0KC9cXHI/XFxuLyk7XG4gIHJldHVybiB7XG4gICAgbGluZTogbGluZXMubGVuZ3RoLFxuXG4gICAgLy8gY29sdW1uIG51bWJlciBpcyBsYXN0IGxpbmUncyBsZW5ndGggKyAxLCBiZWNhdXNlIGNvbHVtbiBudW1iZXJpbmcgc3RhcnRzIGF0IDE6XG4gICAgY29sOiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggKyAxXG4gIH07XG59XG5cbi8vdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIG1hdGNoIHdpdGhpbiBhdHRyU3RyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbkZyb21NYXRjaChtYXRjaCkge1xuICByZXR1cm4gbWF0Y2guc3RhcnRJbmRleCArIG1hdGNoWzFdLmxlbmd0aDtcbn1cbiJdLCJuYW1lcyI6WyJnZXRBbGxNYXRjaGVzIiwiaXNOYW1lIiwiZGVmYXVsdE9wdGlvbnMiLCJhbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzIiwidW5wYWlyZWRUYWdzIiwidmFsaWRhdGUiLCJ4bWxEYXRhIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsInRhZ3MiLCJ0YWdGb3VuZCIsInJlYWNoZWRSb290Iiwic3Vic3RyIiwiaSIsImxlbmd0aCIsInJlYWRQSSIsImVyciIsInRhZ1N0YXJ0UG9zIiwicmVhZENvbW1lbnRBbmRDREFUQSIsImNsb3NpbmdUYWciLCJ0YWdOYW1lIiwidHJpbSIsInN1YnN0cmluZyIsInZhbGlkYXRlVGFnTmFtZSIsIm1zZyIsImdldEVycm9yT2JqZWN0IiwiZ2V0TGluZU51bWJlckZvclBvc2l0aW9uIiwicmVzdWx0IiwicmVhZEF0dHJpYnV0ZVN0ciIsImF0dHJTdHIiLCJ2YWx1ZSIsImluZGV4IiwiYXR0clN0clN0YXJ0IiwiaXNWYWxpZCIsInZhbGlkYXRlQXR0cmlidXRlU3RyaW5nIiwiY29kZSIsImxpbmUiLCJ0YWdDbG9zZWQiLCJvdGciLCJwb3AiLCJvcGVuUG9zIiwiY29sIiwiaW5kZXhPZiIsInB1c2giLCJhZnRlckFtcCIsInZhbGlkYXRlQW1wZXJzYW5kIiwiaXNXaGl0ZVNwYWNlIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1hcCIsInQiLCJyZXBsYWNlIiwiY2hhciIsInN0YXJ0IiwidGFnbmFtZSIsImFuZ2xlQnJhY2tldHNDb3VudCIsImRvdWJsZVF1b3RlIiwic2luZ2xlUXVvdGUiLCJzdGFydENoYXIiLCJ2YWxpZEF0dHJTdHJSZWd4cCIsIlJlZ0V4cCIsIm1hdGNoZXMiLCJhdHRyTmFtZXMiLCJnZXRQb3NpdGlvbkZyb21NYXRjaCIsInVuZGVmaW5lZCIsImF0dHJOYW1lIiwidmFsaWRhdGVBdHRyTmFtZSIsImhhc093blByb3BlcnR5IiwidmFsaWRhdGVOdW1iZXJBbXBlcnNhbmQiLCJyZSIsIm1hdGNoIiwiY291bnQiLCJtZXNzYWdlIiwibGluZU51bWJlciIsImxpbmVzIiwic3BsaXQiLCJzdGFydEluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/fast-xml-parser/src/validator.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js":
/*!**********************************************************************!*\
  !*** ../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ readDocType)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util.js */ \"(rsc)/../node_modules/fast-xml-parser/src/util.js\");\n\n//TODO: handle comments\nfunction readDocType(xmlData, i) {\n    const entities = {};\n    if (xmlData[i + 3] === \"O\" && xmlData[i + 4] === \"C\" && xmlData[i + 5] === \"T\" && xmlData[i + 6] === \"Y\" && xmlData[i + 7] === \"P\" && xmlData[i + 8] === \"E\") {\n        i = i + 9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(; i < xmlData.length; i++){\n            if (xmlData[i] === \"<\" && !comment) {\n                if (hasBody && hasSeq(xmlData, \"!ENTITY\", i)) {\n                    i += 7;\n                    let entityName, val;\n                    [entityName, val, i] = readEntityExp(xmlData, i + 1);\n                    if (val.indexOf(\"&\") === -1) entities[entityName] = {\n                        regx: RegExp(`&${entityName};`, \"g\"),\n                        val: val\n                    };\n                } else if (hasBody && hasSeq(xmlData, \"!ELEMENT\", i)) {\n                    i += 8; //Not supported\n                    const { index } = readElementExp(xmlData, i + 1);\n                    i = index;\n                } else if (hasBody && hasSeq(xmlData, \"!ATTLIST\", i)) {\n                    i += 8; //Not supported\n                // const {index} = readAttlistExp(xmlData,i+1);\n                // i = index;\n                } else if (hasBody && hasSeq(xmlData, \"!NOTATION\", i)) {\n                    i += 9; //Not supported\n                    const { index } = readNotationExp(xmlData, i + 1);\n                    i = index;\n                } else if (hasSeq(xmlData, \"!--\", i)) comment = true;\n                else throw new Error(`Invalid DOCTYPE`);\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === \">\") {\n                if (comment) {\n                    if (xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\") {\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                } else {\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            } else if (xmlData[i] === \"[\") {\n                hasBody = true;\n            } else {\n                exp += xmlData[i];\n            }\n        }\n        if (angleBracketsCount !== 0) {\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    } else {\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {\n        entities,\n        i\n    };\n}\nconst skipWhitespace = (data, index)=>{\n    while(index < data.length && /\\s/.test(data[index])){\n        index++;\n    }\n    return index;\n};\nfunction readEntityExp(xmlData, i) {\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    // Skip leading whitespace after <!ENTITY\n    i = skipWhitespace(xmlData, i);\n    // Read entity name\n    let entityName = \"\";\n    while(i < xmlData.length && !/\\s/.test(xmlData[i]) && xmlData[i] !== '\"' && xmlData[i] !== \"'\"){\n        entityName += xmlData[i];\n        i++;\n    }\n    validateEntityName(entityName);\n    // Skip whitespace after entity name\n    i = skipWhitespace(xmlData, i);\n    // Check for unsupported constructs (external entities or parameter entities)\n    if (xmlData.substring(i, i + 6).toUpperCase() === \"SYSTEM\") {\n        throw new Error(\"External entities are not supported\");\n    } else if (xmlData[i] === \"%\") {\n        throw new Error(\"Parameter entities are not supported\");\n    }\n    // Read entity value (internal entity)\n    let entityValue = \"\";\n    [i, entityValue] = readIdentifierVal(xmlData, i, \"entity\");\n    i--;\n    return [\n        entityName,\n        entityValue,\n        i\n    ];\n}\nfunction readNotationExp(xmlData, i) {\n    // Skip leading whitespace after <!NOTATION\n    i = skipWhitespace(xmlData, i);\n    // Read notation name\n    let notationName = \"\";\n    while(i < xmlData.length && !/\\s/.test(xmlData[i])){\n        notationName += xmlData[i];\n        i++;\n    }\n    validateEntityName(notationName);\n    // Skip whitespace after notation name\n    i = skipWhitespace(xmlData, i);\n    // Check identifier type (SYSTEM or PUBLIC)\n    const identifierType = xmlData.substring(i, i + 6).toUpperCase();\n    if (identifierType !== \"SYSTEM\" && identifierType !== \"PUBLIC\") {\n        throw new Error(`Expected SYSTEM or PUBLIC, found \"${identifierType}\"`);\n    }\n    i += identifierType.length;\n    // Skip whitespace after identifier type\n    i = skipWhitespace(xmlData, i);\n    // Read public identifier (if PUBLIC)\n    let publicIdentifier = null;\n    let systemIdentifier = null;\n    if (identifierType === \"PUBLIC\") {\n        [i, publicIdentifier] = readIdentifierVal(xmlData, i, \"publicIdentifier\");\n        // Skip whitespace after public identifier\n        i = skipWhitespace(xmlData, i);\n        // Optionally read system identifier\n        if (xmlData[i] === '\"' || xmlData[i] === \"'\") {\n            [i, systemIdentifier] = readIdentifierVal(xmlData, i, \"systemIdentifier\");\n        }\n    } else if (identifierType === \"SYSTEM\") {\n        // Read system identifier (mandatory for SYSTEM)\n        [i, systemIdentifier] = readIdentifierVal(xmlData, i, \"systemIdentifier\");\n        if (!systemIdentifier) {\n            throw new Error(\"Missing mandatory system identifier for SYSTEM notation\");\n        }\n    }\n    return {\n        notationName,\n        publicIdentifier,\n        systemIdentifier,\n        index: --i\n    };\n}\nfunction readIdentifierVal(xmlData, i, type) {\n    let identifierVal = \"\";\n    const startChar = xmlData[i];\n    if (startChar !== '\"' && startChar !== \"'\") {\n        throw new Error(`Expected quoted string, found \"${startChar}\"`);\n    }\n    i++;\n    while(i < xmlData.length && xmlData[i] !== startChar){\n        identifierVal += xmlData[i];\n        i++;\n    }\n    if (xmlData[i] !== startChar) {\n        throw new Error(`Unterminated ${type} value`);\n    }\n    i++;\n    return [\n        i,\n        identifierVal\n    ];\n}\nfunction readElementExp(xmlData, i) {\n    // <!ELEMENT br EMPTY>\n    // <!ELEMENT div ANY>\n    // <!ELEMENT title (#PCDATA)>\n    // <!ELEMENT book (title, author+)>\n    // <!ELEMENT name (content-model)>\n    // Skip leading whitespace after <!ELEMENT\n    i = skipWhitespace(xmlData, i);\n    // Read element name\n    let elementName = \"\";\n    while(i < xmlData.length && !/\\s/.test(xmlData[i])){\n        elementName += xmlData[i];\n        i++;\n    }\n    // Validate element name\n    if (!validateEntityName(elementName)) {\n        throw new Error(`Invalid element name: \"${elementName}\"`);\n    }\n    // Skip whitespace after element name\n    i = skipWhitespace(xmlData, i);\n    let contentModel = \"\";\n    // Expect '(' to start content model\n    if (xmlData[i] === \"E\" && hasSeq(xmlData, \"MPTY\", i)) i += 4;\n    else if (xmlData[i] === \"A\" && hasSeq(xmlData, \"NY\", i)) i += 2;\n    else if (xmlData[i] === \"(\") {\n        i++; // Move past '('\n        // Read content model\n        while(i < xmlData.length && xmlData[i] !== \")\"){\n            contentModel += xmlData[i];\n            i++;\n        }\n        if (xmlData[i] !== \")\") {\n            throw new Error(\"Unterminated content model\");\n        }\n    } else {\n        throw new Error(`Invalid Element Expression, found \"${xmlData[i]}\"`);\n    }\n    return {\n        elementName,\n        contentModel: contentModel.trim(),\n        index: i\n    };\n}\nfunction readAttlistExp(xmlData, i) {\n    // Skip leading whitespace after <!ATTLIST\n    i = skipWhitespace(xmlData, i);\n    // Read element name\n    let elementName = \"\";\n    while(i < xmlData.length && !/\\s/.test(xmlData[i])){\n        elementName += xmlData[i];\n        i++;\n    }\n    // Validate element name\n    validateEntityName(elementName);\n    // Skip whitespace after element name\n    i = skipWhitespace(xmlData, i);\n    // Read attribute name\n    let attributeName = \"\";\n    while(i < xmlData.length && !/\\s/.test(xmlData[i])){\n        attributeName += xmlData[i];\n        i++;\n    }\n    // Validate attribute name\n    if (!validateEntityName(attributeName)) {\n        throw new Error(`Invalid attribute name: \"${attributeName}\"`);\n    }\n    // Skip whitespace after attribute name\n    i = skipWhitespace(xmlData, i);\n    // Read attribute type\n    let attributeType = \"\";\n    if (xmlData.substring(i, i + 8).toUpperCase() === \"NOTATION\") {\n        attributeType = \"NOTATION\";\n        i += 8; // Move past \"NOTATION\"\n        // Skip whitespace after \"NOTATION\"\n        i = skipWhitespace(xmlData, i);\n        // Expect '(' to start the list of notations\n        if (xmlData[i] !== \"(\") {\n            throw new Error(`Expected '(', found \"${xmlData[i]}\"`);\n        }\n        i++; // Move past '('\n        // Read the list of allowed notations\n        let allowedNotations = [];\n        while(i < xmlData.length && xmlData[i] !== \")\"){\n            let notation = \"\";\n            while(i < xmlData.length && xmlData[i] !== \"|\" && xmlData[i] !== \")\"){\n                notation += xmlData[i];\n                i++;\n            }\n            // Validate notation name\n            notation = notation.trim();\n            if (!validateEntityName(notation)) {\n                throw new Error(`Invalid notation name: \"${notation}\"`);\n            }\n            allowedNotations.push(notation);\n            // Skip '|' separator or exit loop\n            if (xmlData[i] === \"|\") {\n                i++; // Move past '|'\n                i = skipWhitespace(xmlData, i); // Skip optional whitespace after '|'\n            }\n        }\n        if (xmlData[i] !== \")\") {\n            throw new Error(\"Unterminated list of notations\");\n        }\n        i++; // Move past ')'\n        // Store the allowed notations as part of the attribute type\n        attributeType += \" (\" + allowedNotations.join(\"|\") + \")\";\n    } else {\n        // Handle simple types (e.g., CDATA, ID, IDREF, etc.)\n        while(i < xmlData.length && !/\\s/.test(xmlData[i])){\n            attributeType += xmlData[i];\n            i++;\n        }\n        // Validate simple attribute type\n        const validTypes = [\n            \"CDATA\",\n            \"ID\",\n            \"IDREF\",\n            \"IDREFS\",\n            \"ENTITY\",\n            \"ENTITIES\",\n            \"NMTOKEN\",\n            \"NMTOKENS\"\n        ];\n        if (!validTypes.includes(attributeType.toUpperCase())) {\n            throw new Error(`Invalid attribute type: \"${attributeType}\"`);\n        }\n    }\n    // Skip whitespace after attribute type\n    i = skipWhitespace(xmlData, i);\n    // Read default value\n    let defaultValue = \"\";\n    if (xmlData.substring(i, i + 8).toUpperCase() === \"#REQUIRED\") {\n        defaultValue = \"#REQUIRED\";\n        i += 8;\n    } else if (xmlData.substring(i, i + 7).toUpperCase() === \"#IMPLIED\") {\n        defaultValue = \"#IMPLIED\";\n        i += 7;\n    } else {\n        [i, defaultValue] = readIdentifierVal(xmlData, i, \"ATTLIST\");\n    }\n    return {\n        elementName,\n        attributeName,\n        attributeType,\n        defaultValue,\n        index: i\n    };\n}\nfunction hasSeq(data, seq, i) {\n    for(let j = 0; j < seq.length; j++){\n        if (seq[j] !== data[i + j + 1]) return false;\n    }\n    return true;\n}\nfunction validateEntityName(name) {\n    if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.isName)(name)) return name;\n    else throw new Error(`Invalid entity name ${name}`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL0RvY1R5cGVSZWFkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7QUFFbEMsdUJBQXVCO0FBQ1IsU0FBU0MsWUFBWUMsT0FBTyxFQUFFQyxDQUFDO0lBRTFDLE1BQU1DLFdBQVcsQ0FBQztJQUNsQixJQUFJRixPQUFPLENBQUNDLElBQUksRUFBRSxLQUFLLE9BQ2xCRCxPQUFPLENBQUNDLElBQUksRUFBRSxLQUFLLE9BQ25CRCxPQUFPLENBQUNDLElBQUksRUFBRSxLQUFLLE9BQ25CRCxPQUFPLENBQUNDLElBQUksRUFBRSxLQUFLLE9BQ25CRCxPQUFPLENBQUNDLElBQUksRUFBRSxLQUFLLE9BQ25CRCxPQUFPLENBQUNDLElBQUksRUFBRSxLQUFLLEtBQ3hCO1FBQ0lBLElBQUlBLElBQUU7UUFDTixJQUFJRSxxQkFBcUI7UUFDekIsSUFBSUMsVUFBVSxPQUFPQyxVQUFVO1FBQy9CLElBQUlDLE1BQU07UUFDVixNQUFLTCxJQUFFRCxRQUFRTyxNQUFNLEVBQUNOLElBQUk7WUFDdEIsSUFBSUQsT0FBTyxDQUFDQyxFQUFFLEtBQUssT0FBTyxDQUFDSSxTQUFTO2dCQUNoQyxJQUFJRCxXQUFXSSxPQUFPUixTQUFTLFdBQVVDLElBQUc7b0JBQ3hDQSxLQUFLO29CQUNMLElBQUlRLFlBQVlDO29CQUNoQixDQUFDRCxZQUFZQyxLQUFJVCxFQUFFLEdBQUdVLGNBQWNYLFNBQVFDLElBQUU7b0JBQzlDLElBQUdTLElBQUlFLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FDckJWLFFBQVEsQ0FBRU8sV0FBWSxHQUFHO3dCQUNyQkksTUFBT0MsT0FBUSxDQUFDLENBQUMsRUFBRUwsV0FBVyxDQUFDLENBQUMsRUFBQzt3QkFDakNDLEtBQUtBO29CQUNUO2dCQUNSLE9BQ0ssSUFBSU4sV0FBV0ksT0FBT1IsU0FBUyxZQUFXQyxJQUFLO29CQUNoREEsS0FBSyxHQUFFLGVBQWU7b0JBQ3RC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QUNmN0MsS0FBSztJQUNULE9BQU8sSUFBSUQsUUFBUXVCLFNBQVMsQ0FBQ3RCLEdBQUdBLElBQUksR0FBR3VCLFdBQVcsT0FBTyxZQUFZO1FBQ2pFc0IsZUFBZTtRQUNmN0MsS0FBSztJQUNULE9BQU87UUFDSCxDQUFDQSxHQUFHNkMsYUFBYSxHQUFHcEIsa0JBQWtCMUIsU0FBU0MsR0FBRztJQUN0RDtJQUVBLE9BQU87UUFDSGlDO1FBQ0FJO1FBQ0FDO1FBQ0FPO1FBQ0EvQixPQUFPZDtJQUNYO0FBQ0o7QUFFQSxTQUFTTyxPQUFPWSxJQUFJLEVBQUUyQixHQUFHLEVBQUM5QyxDQUFDO0lBQ3ZCLElBQUksSUFBSStDLElBQUUsR0FBRUEsSUFBRUQsSUFBSXhDLE1BQU0sRUFBQ3lDLElBQUk7UUFDekIsSUFBR0QsR0FBRyxDQUFDQyxFQUFFLEtBQUc1QixJQUFJLENBQUNuQixJQUFFK0MsSUFBRSxFQUFFLEVBQUUsT0FBTztJQUNwQztJQUNBLE9BQU87QUFDWDtBQUVBLFNBQVMxQixtQkFBbUIyQixJQUFJO0lBQzVCLElBQUluRCxnREFBTUEsQ0FBQ21ELE9BQ2QsT0FBT0E7U0FFQSxNQUFNLElBQUkvQixNQUFNLENBQUMsb0JBQW9CLEVBQUUrQixLQUFLLENBQUM7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYWxlcy1kYXNoYm9hcmQtZnJvbnRlbmQvLi4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL0RvY1R5cGVSZWFkZXIuanM/YzM3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge2lzTmFtZX0gZnJvbSAnLi4vdXRpbC5qcyc7XG5cbi8vVE9ETzogaGFuZGxlIGNvbW1lbnRzXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWFkRG9jVHlwZSh4bWxEYXRhLCBpKXtcbiAgICBcbiAgICBjb25zdCBlbnRpdGllcyA9IHt9O1xuICAgIGlmKCB4bWxEYXRhW2kgKyAzXSA9PT0gJ08nICYmXG4gICAgICAgICB4bWxEYXRhW2kgKyA0XSA9PT0gJ0MnICYmXG4gICAgICAgICB4bWxEYXRhW2kgKyA1XSA9PT0gJ1QnICYmXG4gICAgICAgICB4bWxEYXRhW2kgKyA2XSA9PT0gJ1knICYmXG4gICAgICAgICB4bWxEYXRhW2kgKyA3XSA9PT0gJ1AnICYmXG4gICAgICAgICB4bWxEYXRhW2kgKyA4XSA9PT0gJ0UnKVxuICAgIHsgICAgXG4gICAgICAgIGkgPSBpKzk7XG4gICAgICAgIGxldCBhbmdsZUJyYWNrZXRzQ291bnQgPSAxO1xuICAgICAgICBsZXQgaGFzQm9keSA9IGZhbHNlLCBjb21tZW50ID0gZmFsc2U7XG4gICAgICAgIGxldCBleHAgPSBcIlwiO1xuICAgICAgICBmb3IoO2k8eG1sRGF0YS5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgIGlmICh4bWxEYXRhW2ldID09PSAnPCcgJiYgIWNvbW1lbnQpIHsgLy9EZXRlcm1pbmUgdGhlIHRhZyB0eXBlXG4gICAgICAgICAgICAgICAgaWYoIGhhc0JvZHkgJiYgaGFzU2VxKHhtbERhdGEsIFwiIUVOVElUWVwiLGkpKXtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA3OyBcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVudGl0eU5hbWUsIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgW2VudGl0eU5hbWUsIHZhbCxpXSA9IHJlYWRFbnRpdHlFeHAoeG1sRGF0YSxpKzEpO1xuICAgICAgICAgICAgICAgICAgICBpZih2YWwuaW5kZXhPZihcIiZcIikgPT09IC0xKSAvL1BhcmFtZXRlciBlbnRpdGllcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXRpZXNbIGVudGl0eU5hbWUgXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWd4IDogUmVnRXhwKCBgJiR7ZW50aXR5TmFtZX07YCxcImdcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsOiB2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoIGhhc0JvZHkgJiYgaGFzU2VxKHhtbERhdGEsIFwiIUVMRU1FTlRcIixpKSkgIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSA4Oy8vTm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7aW5kZXh9ID0gcmVhZEVsZW1lbnRFeHAoeG1sRGF0YSxpKzEpO1xuICAgICAgICAgICAgICAgICAgICBpID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoIGhhc0JvZHkgJiYgaGFzU2VxKHhtbERhdGEsIFwiIUFUVExJU1RcIixpKSl7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gODsvL05vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3Qge2luZGV4fSA9IHJlYWRBdHRsaXN0RXhwKHhtbERhdGEsaSsxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaSA9IGluZGV4O1xuICAgICAgICAgICAgICAgIH1lbHNlIGlmKCBoYXNCb2R5ICYmIGhhc1NlcSh4bWxEYXRhLCBcIiFOT1RBVElPTlwiLGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gOTsvL05vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qge2luZGV4fSA9IHJlYWROb3RhdGlvbkV4cCh4bWxEYXRhLGkrMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZiggaGFzU2VxKHhtbERhdGEsIFwiIS0tXCIsaSkgKSBjb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBET0NUWVBFYCk7XG5cbiAgICAgICAgICAgICAgICBhbmdsZUJyYWNrZXRzQ291bnQrKztcbiAgICAgICAgICAgICAgICBleHAgPSBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4bWxEYXRhW2ldID09PSAnPicpIHsgLy9SZWFkIHRhZyBjb250ZW50XG4gICAgICAgICAgICAgICAgaWYoY29tbWVudCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCB4bWxEYXRhW2kgLSAxXSA9PT0gXCItXCIgJiYgeG1sRGF0YVtpIC0gMl0gPT09IFwiLVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlQnJhY2tldHNDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlQnJhY2tldHNDb3VudC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYW5nbGVCcmFja2V0c0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZSBpZiggeG1sRGF0YVtpXSA9PT0gJ1snKXtcbiAgICAgICAgICAgICAgICBoYXNCb2R5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGV4cCArPSB4bWxEYXRhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFuZ2xlQnJhY2tldHNDb3VudCAhPT0gMCl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuY2xvc2VkIERPQ1RZUEVgKTtcbiAgICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVGFnIGluc3RlYWQgb2YgRE9DVFlQRWApO1xuICAgIH1cbiAgICByZXR1cm4ge2VudGl0aWVzLCBpfTtcbn1cblxuY29uc3Qgc2tpcFdoaXRlc3BhY2UgPSAoZGF0YSwgaW5kZXgpID0+IHtcbiAgICB3aGlsZSAoaW5kZXggPCBkYXRhLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGRhdGFbaW5kZXhdKSkge1xuICAgICAgICBpbmRleCsrO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG5mdW5jdGlvbiByZWFkRW50aXR5RXhwKHhtbERhdGEsIGkpIHsgICAgXG4gICAgLy9FeHRlcm5hbCBlbnRpdGllcyBhcmUgbm90IHN1cHBvcnRlZFxuICAgIC8vICAgIDwhRU5USVRZIGV4dCBTWVNURU0gXCJodHRwOi8vbm9ybWFsLXdlYnNpdGUuY29tXCIgPlxuXG4gICAgLy9QYXJhbWV0ZXIgZW50aXRpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAvLyAgICA8IUVOVElUWSBlbnRpdHluYW1lIFwiJmFub3RoZXJFbGVtZW50O1wiPlxuXG4gICAgLy9JbnRlcm5hbCBlbnRpdGllcyBhcmUgc3VwcG9ydGVkXG4gICAgLy8gICAgPCFFTlRJVFkgZW50aXR5bmFtZSBcInJlcGxhY2VtZW50IHRleHRcIj5cblxuICAgIC8vIFNraXAgbGVhZGluZyB3aGl0ZXNwYWNlIGFmdGVyIDwhRU5USVRZXG4gICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpO1xuXG4gICAgLy8gUmVhZCBlbnRpdHkgbmFtZVxuICAgIGxldCBlbnRpdHlOYW1lID0gXCJcIjtcbiAgICB3aGlsZSAoaSA8IHhtbERhdGEubGVuZ3RoICYmICEvXFxzLy50ZXN0KHhtbERhdGFbaV0pICYmIHhtbERhdGFbaV0gIT09ICdcIicgJiYgeG1sRGF0YVtpXSAhPT0gXCInXCIpIHtcbiAgICAgICAgZW50aXR5TmFtZSArPSB4bWxEYXRhW2ldO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHZhbGlkYXRlRW50aXR5TmFtZShlbnRpdHlOYW1lKTtcblxuICAgIC8vIFNraXAgd2hpdGVzcGFjZSBhZnRlciBlbnRpdHkgbmFtZVxuICAgIGkgPSBza2lwV2hpdGVzcGFjZSh4bWxEYXRhLCBpKTtcblxuICAgIC8vIENoZWNrIGZvciB1bnN1cHBvcnRlZCBjb25zdHJ1Y3RzIChleHRlcm5hbCBlbnRpdGllcyBvciBwYXJhbWV0ZXIgZW50aXRpZXMpXG4gICAgaWYgKHhtbERhdGEuc3Vic3RyaW5nKGksIGkgKyA2KS50b1VwcGVyQ2FzZSgpID09PSBcIlNZU1RFTVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4dGVybmFsIGVudGl0aWVzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1lbHNlIGlmICh4bWxEYXRhW2ldID09PSBcIiVcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgZW50aXRpZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuXG4gICAgLy8gUmVhZCBlbnRpdHkgdmFsdWUgKGludGVybmFsIGVudGl0eSlcbiAgICBsZXQgZW50aXR5VmFsdWUgPSBcIlwiO1xuICAgIFtpLCBlbnRpdHlWYWx1ZV0gPSByZWFkSWRlbnRpZmllclZhbCh4bWxEYXRhLCBpLCBcImVudGl0eVwiKTtcbiAgICBpLS07XG4gICAgcmV0dXJuIFtlbnRpdHlOYW1lLCBlbnRpdHlWYWx1ZSwgaSBdO1xufVxuXG5mdW5jdGlvbiByZWFkTm90YXRpb25FeHAoeG1sRGF0YSwgaSkge1xuICAgIC8vIFNraXAgbGVhZGluZyB3aGl0ZXNwYWNlIGFmdGVyIDwhTk9UQVRJT05cbiAgICBpID0gc2tpcFdoaXRlc3BhY2UoeG1sRGF0YSwgaSk7XG5cbiAgICAvLyBSZWFkIG5vdGF0aW9uIG5hbWVcbiAgICBsZXQgbm90YXRpb25OYW1lID0gXCJcIjtcbiAgICB3aGlsZSAoaSA8IHhtbERhdGEubGVuZ3RoICYmICEvXFxzLy50ZXN0KHhtbERhdGFbaV0pKSB7XG4gICAgICAgIG5vdGF0aW9uTmFtZSArPSB4bWxEYXRhW2ldO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHZhbGlkYXRlRW50aXR5TmFtZShub3RhdGlvbk5hbWUpO1xuXG4gICAgLy8gU2tpcCB3aGl0ZXNwYWNlIGFmdGVyIG5vdGF0aW9uIG5hbWVcbiAgICBpID0gc2tpcFdoaXRlc3BhY2UoeG1sRGF0YSwgaSk7XG5cbiAgICAvLyBDaGVjayBpZGVudGlmaWVyIHR5cGUgKFNZU1RFTSBvciBQVUJMSUMpXG4gICAgY29uc3QgaWRlbnRpZmllclR5cGUgPSB4bWxEYXRhLnN1YnN0cmluZyhpLCBpICsgNikudG9VcHBlckNhc2UoKTtcbiAgICBpZiAoaWRlbnRpZmllclR5cGUgIT09IFwiU1lTVEVNXCIgJiYgaWRlbnRpZmllclR5cGUgIT09IFwiUFVCTElDXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBTWVNURU0gb3IgUFVCTElDLCBmb3VuZCBcIiR7aWRlbnRpZmllclR5cGV9XCJgKTtcbiAgICB9XG4gICAgaSArPSBpZGVudGlmaWVyVHlwZS5sZW5ndGg7XG5cbiAgICAvLyBTa2lwIHdoaXRlc3BhY2UgYWZ0ZXIgaWRlbnRpZmllciB0eXBlXG4gICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpO1xuXG4gICAgLy8gUmVhZCBwdWJsaWMgaWRlbnRpZmllciAoaWYgUFVCTElDKVxuICAgIGxldCBwdWJsaWNJZGVudGlmaWVyID0gbnVsbDtcbiAgICBsZXQgc3lzdGVtSWRlbnRpZmllciA9IG51bGw7XG5cbiAgICBpZiAoaWRlbnRpZmllclR5cGUgPT09IFwiUFVCTElDXCIpIHtcbiAgICAgICAgW2ksIHB1YmxpY0lkZW50aWZpZXIgXSA9IHJlYWRJZGVudGlmaWVyVmFsKHhtbERhdGEsIGksIFwicHVibGljSWRlbnRpZmllclwiKTtcblxuICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgYWZ0ZXIgcHVibGljIGlkZW50aWZpZXJcbiAgICAgICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpO1xuXG4gICAgICAgIC8vIE9wdGlvbmFsbHkgcmVhZCBzeXN0ZW0gaWRlbnRpZmllclxuICAgICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gJ1wiJyB8fCB4bWxEYXRhW2ldID09PSBcIidcIikge1xuICAgICAgICAgICAgW2ksIHN5c3RlbUlkZW50aWZpZXIgXSA9IHJlYWRJZGVudGlmaWVyVmFsKHhtbERhdGEsIGksXCJzeXN0ZW1JZGVudGlmaWVyXCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChpZGVudGlmaWVyVHlwZSA9PT0gXCJTWVNURU1cIikge1xuICAgICAgICAvLyBSZWFkIHN5c3RlbSBpZGVudGlmaWVyIChtYW5kYXRvcnkgZm9yIFNZU1RFTSlcbiAgICAgICAgW2ksIHN5c3RlbUlkZW50aWZpZXIgXSA9IHJlYWRJZGVudGlmaWVyVmFsKHhtbERhdGEsIGksIFwic3lzdGVtSWRlbnRpZmllclwiKTtcblxuICAgICAgICBpZiAoIXN5c3RlbUlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgbWFuZGF0b3J5IHN5c3RlbSBpZGVudGlmaWVyIGZvciBTWVNURU0gbm90YXRpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtub3RhdGlvbk5hbWUsIHB1YmxpY0lkZW50aWZpZXIsIHN5c3RlbUlkZW50aWZpZXIsIGluZGV4OiAtLWl9O1xufVxuXG5mdW5jdGlvbiByZWFkSWRlbnRpZmllclZhbCh4bWxEYXRhLCBpLCB0eXBlKSB7XG4gICAgbGV0IGlkZW50aWZpZXJWYWwgPSBcIlwiO1xuICAgIGNvbnN0IHN0YXJ0Q2hhciA9IHhtbERhdGFbaV07XG4gICAgaWYgKHN0YXJ0Q2hhciAhPT0gJ1wiJyAmJiBzdGFydENoYXIgIT09IFwiJ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgcXVvdGVkIHN0cmluZywgZm91bmQgXCIke3N0YXJ0Q2hhcn1cImApO1xuICAgIH1cbiAgICBpKys7XG5cbiAgICB3aGlsZSAoaSA8IHhtbERhdGEubGVuZ3RoICYmIHhtbERhdGFbaV0gIT09IHN0YXJ0Q2hhcikge1xuICAgICAgICBpZGVudGlmaWVyVmFsICs9IHhtbERhdGFbaV07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpZiAoeG1sRGF0YVtpXSAhPT0gc3RhcnRDaGFyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW50ZXJtaW5hdGVkICR7dHlwZX0gdmFsdWVgKTtcbiAgICB9XG4gICAgaSsrO1xuICAgIHJldHVybiBbaSwgaWRlbnRpZmllclZhbF07XG59XG5cbmZ1bmN0aW9uIHJlYWRFbGVtZW50RXhwKHhtbERhdGEsIGkpIHtcbiAgICAvLyA8IUVMRU1FTlQgYnIgRU1QVFk+XG4gICAgLy8gPCFFTEVNRU5UIGRpdiBBTlk+XG4gICAgLy8gPCFFTEVNRU5UIHRpdGxlICgjUENEQVRBKT5cbiAgICAvLyA8IUVMRU1FTlQgYm9vayAodGl0bGUsIGF1dGhvcispPlxuICAgIC8vIDwhRUxFTUVOVCBuYW1lIChjb250ZW50LW1vZGVsKT5cbiAgICBcbiAgICAvLyBTa2lwIGxlYWRpbmcgd2hpdGVzcGFjZSBhZnRlciA8IUVMRU1FTlRcbiAgICBpID0gc2tpcFdoaXRlc3BhY2UoeG1sRGF0YSwgaSk7XG5cbiAgICAvLyBSZWFkIGVsZW1lbnQgbmFtZVxuICAgIGxldCBlbGVtZW50TmFtZSA9IFwiXCI7XG4gICAgd2hpbGUgKGkgPCB4bWxEYXRhLmxlbmd0aCAmJiAhL1xccy8udGVzdCh4bWxEYXRhW2ldKSkge1xuICAgICAgICBlbGVtZW50TmFtZSArPSB4bWxEYXRhW2ldO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgZWxlbWVudCBuYW1lXG4gICAgaWYgKCF2YWxpZGF0ZUVudGl0eU5hbWUoZWxlbWVudE5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbGVtZW50IG5hbWU6IFwiJHtlbGVtZW50TmFtZX1cImApO1xuICAgIH1cblxuICAgIC8vIFNraXAgd2hpdGVzcGFjZSBhZnRlciBlbGVtZW50IG5hbWVcbiAgICBpID0gc2tpcFdoaXRlc3BhY2UoeG1sRGF0YSwgaSk7XG4gICAgbGV0IGNvbnRlbnRNb2RlbCA9IFwiXCI7XG4gICAgLy8gRXhwZWN0ICcoJyB0byBzdGFydCBjb250ZW50IG1vZGVsXG4gICAgaWYoeG1sRGF0YVtpXSA9PT0gXCJFXCIgJiYgaGFzU2VxKHhtbERhdGEsIFwiTVBUWVwiLGkpKSBpKz00O1xuICAgIGVsc2UgaWYoeG1sRGF0YVtpXSA9PT0gXCJBXCIgJiYgaGFzU2VxKHhtbERhdGEsIFwiTllcIixpKSkgaSs9MjtcbiAgICBlbHNlIGlmICh4bWxEYXRhW2ldID09PSBcIihcIikge1xuICAgICAgICBpKys7IC8vIE1vdmUgcGFzdCAnKCdcblxuICAgICAgICAvLyBSZWFkIGNvbnRlbnQgbW9kZWxcbiAgICAgICAgd2hpbGUgKGkgPCB4bWxEYXRhLmxlbmd0aCAmJiB4bWxEYXRhW2ldICE9PSBcIilcIikge1xuICAgICAgICAgICAgY29udGVudE1vZGVsICs9IHhtbERhdGFbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHhtbERhdGFbaV0gIT09IFwiKVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnRlcm1pbmF0ZWQgY29udGVudCBtb2RlbFwiKTtcbiAgICAgICAgfVxuXG4gICAgfWVsc2V7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBFbGVtZW50IEV4cHJlc3Npb24sIGZvdW5kIFwiJHt4bWxEYXRhW2ldfVwiYCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnROYW1lLFxuICAgICAgICBjb250ZW50TW9kZWw6IGNvbnRlbnRNb2RlbC50cmltKCksXG4gICAgICAgIGluZGV4OiBpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmVhZEF0dGxpc3RFeHAoeG1sRGF0YSwgaSkge1xuICAgIC8vIFNraXAgbGVhZGluZyB3aGl0ZXNwYWNlIGFmdGVyIDwhQVRUTElTVFxuICAgIGkgPSBza2lwV2hpdGVzcGFjZSh4bWxEYXRhLCBpKTtcblxuICAgIC8vIFJlYWQgZWxlbWVudCBuYW1lXG4gICAgbGV0IGVsZW1lbnROYW1lID0gXCJcIjtcbiAgICB3aGlsZSAoaSA8IHhtbERhdGEubGVuZ3RoICYmICEvXFxzLy50ZXN0KHhtbERhdGFbaV0pKSB7XG4gICAgICAgIGVsZW1lbnROYW1lICs9IHhtbERhdGFbaV07XG4gICAgICAgIGkrKztcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSBlbGVtZW50IG5hbWVcbiAgICB2YWxpZGF0ZUVudGl0eU5hbWUoZWxlbWVudE5hbWUpXG5cbiAgICAvLyBTa2lwIHdoaXRlc3BhY2UgYWZ0ZXIgZWxlbWVudCBuYW1lXG4gICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpO1xuXG4gICAgLy8gUmVhZCBhdHRyaWJ1dGUgbmFtZVxuICAgIGxldCBhdHRyaWJ1dGVOYW1lID0gXCJcIjtcbiAgICB3aGlsZSAoaSA8IHhtbERhdGEubGVuZ3RoICYmICEvXFxzLy50ZXN0KHhtbERhdGFbaV0pKSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWUgKz0geG1sRGF0YVtpXTtcbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGF0dHJpYnV0ZSBuYW1lXG4gICAgaWYgKCF2YWxpZGF0ZUVudGl0eU5hbWUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBcIiR7YXR0cmlidXRlTmFtZX1cImApO1xuICAgIH1cblxuICAgIC8vIFNraXAgd2hpdGVzcGFjZSBhZnRlciBhdHRyaWJ1dGUgbmFtZVxuICAgIGkgPSBza2lwV2hpdGVzcGFjZSh4bWxEYXRhLCBpKTtcblxuICAgIC8vIFJlYWQgYXR0cmlidXRlIHR5cGVcbiAgICBsZXQgYXR0cmlidXRlVHlwZSA9IFwiXCI7XG4gICAgaWYgKHhtbERhdGEuc3Vic3RyaW5nKGksIGkgKyA4KS50b1VwcGVyQ2FzZSgpID09PSBcIk5PVEFUSU9OXCIpIHtcbiAgICAgICAgYXR0cmlidXRlVHlwZSA9IFwiTk9UQVRJT05cIjtcbiAgICAgICAgaSArPSA4OyAvLyBNb3ZlIHBhc3QgXCJOT1RBVElPTlwiXG5cbiAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIGFmdGVyIFwiTk9UQVRJT05cIlxuICAgICAgICBpID0gc2tpcFdoaXRlc3BhY2UoeG1sRGF0YSwgaSk7XG5cbiAgICAgICAgLy8gRXhwZWN0ICcoJyB0byBzdGFydCB0aGUgbGlzdCBvZiBub3RhdGlvbnNcbiAgICAgICAgaWYgKHhtbERhdGFbaV0gIT09IFwiKFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICcoJywgZm91bmQgXCIke3htbERhdGFbaV19XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7IC8vIE1vdmUgcGFzdCAnKCdcblxuICAgICAgICAvLyBSZWFkIHRoZSBsaXN0IG9mIGFsbG93ZWQgbm90YXRpb25zXG4gICAgICAgIGxldCBhbGxvd2VkTm90YXRpb25zID0gW107XG4gICAgICAgIHdoaWxlIChpIDwgeG1sRGF0YS5sZW5ndGggJiYgeG1sRGF0YVtpXSAhPT0gXCIpXCIpIHtcbiAgICAgICAgICAgIGxldCBub3RhdGlvbiA9IFwiXCI7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHhtbERhdGEubGVuZ3RoICYmIHhtbERhdGFbaV0gIT09IFwifFwiICYmIHhtbERhdGFbaV0gIT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgbm90YXRpb24gKz0geG1sRGF0YVtpXTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIG5vdGF0aW9uIG5hbWVcbiAgICAgICAgICAgIG5vdGF0aW9uID0gbm90YXRpb24udHJpbSgpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUVudGl0eU5hbWUobm90YXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG5vdGF0aW9uIG5hbWU6IFwiJHtub3RhdGlvbn1cImApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbGxvd2VkTm90YXRpb25zLnB1c2gobm90YXRpb24pO1xuXG4gICAgICAgICAgICAvLyBTa2lwICd8JyBzZXBhcmF0b3Igb3IgZXhpdCBsb29wXG4gICAgICAgICAgICBpZiAoeG1sRGF0YVtpXSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICBpKys7IC8vIE1vdmUgcGFzdCAnfCdcbiAgICAgICAgICAgICAgICBpID0gc2tpcFdoaXRlc3BhY2UoeG1sRGF0YSwgaSk7IC8vIFNraXAgb3B0aW9uYWwgd2hpdGVzcGFjZSBhZnRlciAnfCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4bWxEYXRhW2ldICE9PSBcIilcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW50ZXJtaW5hdGVkIGxpc3Qgb2Ygbm90YXRpb25zXCIpO1xuICAgICAgICB9XG4gICAgICAgIGkrKzsgLy8gTW92ZSBwYXN0ICcpJ1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBhbGxvd2VkIG5vdGF0aW9ucyBhcyBwYXJ0IG9mIHRoZSBhdHRyaWJ1dGUgdHlwZVxuICAgICAgICBhdHRyaWJ1dGVUeXBlICs9IFwiIChcIiArIGFsbG93ZWROb3RhdGlvbnMuam9pbihcInxcIikgKyBcIilcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgc2ltcGxlIHR5cGVzIChlLmcuLCBDREFUQSwgSUQsIElEUkVGLCBldGMuKVxuICAgICAgICB3aGlsZSAoaSA8IHhtbERhdGEubGVuZ3RoICYmICEvXFxzLy50ZXN0KHhtbERhdGFbaV0pKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVUeXBlICs9IHhtbERhdGFbaV07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBWYWxpZGF0ZSBzaW1wbGUgYXR0cmlidXRlIHR5cGVcbiAgICAgICAgY29uc3QgdmFsaWRUeXBlcyA9IFtcIkNEQVRBXCIsIFwiSURcIiwgXCJJRFJFRlwiLCBcIklEUkVGU1wiLCBcIkVOVElUWVwiLCBcIkVOVElUSUVTXCIsIFwiTk1UT0tFTlwiLCBcIk5NVE9LRU5TXCJdO1xuICAgICAgICBpZiAoIXZhbGlkVHlwZXMuaW5jbHVkZXMoYXR0cmlidXRlVHlwZS50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGF0dHJpYnV0ZSB0eXBlOiBcIiR7YXR0cmlidXRlVHlwZX1cImApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2tpcCB3aGl0ZXNwYWNlIGFmdGVyIGF0dHJpYnV0ZSB0eXBlXG4gICAgaSA9IHNraXBXaGl0ZXNwYWNlKHhtbERhdGEsIGkpO1xuXG4gICAgLy8gUmVhZCBkZWZhdWx0IHZhbHVlXG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IFwiXCI7XG4gICAgaWYgKHhtbERhdGEuc3Vic3RyaW5nKGksIGkgKyA4KS50b1VwcGVyQ2FzZSgpID09PSBcIiNSRVFVSVJFRFwiKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9IFwiI1JFUVVJUkVEXCI7XG4gICAgICAgIGkgKz0gODtcbiAgICB9IGVsc2UgaWYgKHhtbERhdGEuc3Vic3RyaW5nKGksIGkgKyA3KS50b1VwcGVyQ2FzZSgpID09PSBcIiNJTVBMSUVEXCIpIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gXCIjSU1QTElFRFwiO1xuICAgICAgICBpICs9IDc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgW2ksIGRlZmF1bHRWYWx1ZV0gPSByZWFkSWRlbnRpZmllclZhbCh4bWxEYXRhLCBpLCBcIkFUVExJU1RcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZWxlbWVudE5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZVR5cGUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZSxcbiAgICAgICAgaW5kZXg6IGlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc1NlcShkYXRhLCBzZXEsaSl7XG4gICAgZm9yKGxldCBqPTA7ajxzZXEubGVuZ3RoO2orKyl7XG4gICAgICAgIGlmKHNlcVtqXSE9PWRhdGFbaStqKzFdKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUVudGl0eU5hbWUobmFtZSl7XG4gICAgaWYgKGlzTmFtZShuYW1lKSlcblx0cmV0dXJuIG5hbWU7XG4gICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZW50aXR5IG5hbWUgJHtuYW1lfWApO1xufVxuIl0sIm5hbWVzIjpbImlzTmFtZSIsInJlYWREb2NUeXBlIiwieG1sRGF0YSIsImkiLCJlbnRpdGllcyIsImFuZ2xlQnJhY2tldHNDb3VudCIsImhhc0JvZHkiLCJjb21tZW50IiwiZXhwIiwibGVuZ3RoIiwiaGFzU2VxIiwiZW50aXR5TmFtZSIsInZhbCIsInJlYWRFbnRpdHlFeHAiLCJpbmRleE9mIiwicmVneCIsIlJlZ0V4cCIsImluZGV4IiwicmVhZEVsZW1lbnRFeHAiLCJyZWFkTm90YXRpb25FeHAiLCJFcnJvciIsInNraXBXaGl0ZXNwYWNlIiwiZGF0YSIsInRlc3QiLCJ2YWxpZGF0ZUVudGl0eU5hbWUiLCJzdWJzdHJpbmciLCJ0b1VwcGVyQ2FzZSIsImVudGl0eVZhbHVlIiwicmVhZElkZW50aWZpZXJWYWwiLCJub3RhdGlvbk5hbWUiLCJpZGVudGlmaWVyVHlwZSIsInB1YmxpY0lkZW50aWZpZXIiLCJzeXN0ZW1JZGVudGlmaWVyIiwidHlwZSIsImlkZW50aWZpZXJWYWwiLCJzdGFydENoYXIiLCJlbGVtZW50TmFtZSIsImNvbnRlbnRNb2RlbCIsInRyaW0iLCJyZWFkQXR0bGlzdEV4cCIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVUeXBlIiwiYWxsb3dlZE5vdGF0aW9ucyIsIm5vdGF0aW9uIiwicHVzaCIsImpvaW4iLCJ2YWxpZFR5cGVzIiwiaW5jbHVkZXMiLCJkZWZhdWx0VmFsdWUiLCJzZXEiLCJqIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js":
/*!***********************************************************************!*\
  !*** ../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildOptions: () => (/* binding */ buildOptions),\n/* harmony export */   defaultOptions: () => (/* binding */ defaultOptions)\n/* harmony export */ });\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: \"@_\",\n    attributesGroupName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    removeNSPrefix: false,\n    allowBooleanAttributes: false,\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true,\n    cdataPropName: false,\n    numberParseOptions: {\n        hex: true,\n        leadingZeros: true,\n        eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n        return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n        return val;\n    },\n    stopNodes: [],\n    alwaysCreateTextNode: false,\n    isArray: ()=>false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs) {\n        return tagName;\n    },\n    // skipEmptyListItem: false\n    captureMetaData: false\n};\nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL09wdGlvbnNCdWlsZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQ08sTUFBTUEsaUJBQWlCO0lBQzFCQyxlQUFlO0lBQ2ZDLHFCQUFxQjtJQUNyQkMscUJBQXFCO0lBQ3JCQyxjQUFjO0lBQ2RDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyx3QkFBd0I7SUFDeEIsNEJBQTRCO0lBQzVCQyxlQUFlO0lBQ2ZDLHFCQUFxQjtJQUNyQkMsWUFBWTtJQUNaQyxlQUFlO0lBQ2ZDLG9CQUFvQjtRQUNsQkMsS0FBSztRQUNMQyxjQUFjO1FBQ2RDLFdBQVc7SUFDYjtJQUNBQyxtQkFBbUIsU0FBU0MsT0FBTyxFQUFFQyxHQUFHO1FBQ3RDLE9BQU9BO0lBQ1Q7SUFDQUMseUJBQXlCLFNBQVNDLFFBQVEsRUFBRUYsR0FBRztRQUM3QyxPQUFPQTtJQUNUO0lBQ0FHLFdBQVcsRUFBRTtJQUNiQyxzQkFBc0I7SUFDdEJDLFNBQVMsSUFBTTtJQUNmQyxpQkFBaUI7SUFDakJDLGNBQWMsRUFBRTtJQUNoQkMsaUJBQWlCO0lBQ2pCQyxjQUFjO0lBQ2RDLG1CQUFtQjtJQUNuQkMsY0FBYztJQUNkQyxrQkFBa0I7SUFDbEJDLHdCQUF3QjtJQUN4QkMsV0FBVyxTQUFTZixPQUFPLEVBQUVnQixLQUFLLEVBQUVDLEtBQUs7UUFDdkMsT0FBT2pCO0lBQ1Q7SUFDQSwyQkFBMkI7SUFDM0JrQixpQkFBaUI7QUFDckIsRUFBRTtBQUVLLE1BQU1DLGVBQWUsU0FBU0MsT0FBTztJQUN4QyxPQUFPQyxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHdkMsZ0JBQWdCcUM7QUFDN0MsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWRhc2hib2FyZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3B0aW9uc0J1aWxkZXIuanM/OGFiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBwcmVzZXJ2ZU9yZGVyOiBmYWxzZSxcbiAgICBhdHRyaWJ1dGVOYW1lUHJlZml4OiAnQF8nLFxuICAgIGF0dHJpYnV0ZXNHcm91cE5hbWU6IGZhbHNlLFxuICAgIHRleHROb2RlTmFtZTogJyN0ZXh0JyxcbiAgICBpZ25vcmVBdHRyaWJ1dGVzOiB0cnVlLFxuICAgIHJlbW92ZU5TUHJlZml4OiBmYWxzZSwgLy8gcmVtb3ZlIE5TIGZyb20gdGFnIG5hbWUgb3IgYXR0cmlidXRlIG5hbWUgaWYgdHJ1ZVxuICAgIGFsbG93Qm9vbGVhbkF0dHJpYnV0ZXM6IGZhbHNlLCAvL2EgdGFnIGNhbiBoYXZlIGF0dHJpYnV0ZXMgd2l0aG91dCBhbnkgdmFsdWVcbiAgICAvL2lnbm9yZVJvb3RFbGVtZW50IDogZmFsc2UsXG4gICAgcGFyc2VUYWdWYWx1ZTogdHJ1ZSxcbiAgICBwYXJzZUF0dHJpYnV0ZVZhbHVlOiBmYWxzZSxcbiAgICB0cmltVmFsdWVzOiB0cnVlLCAvL1RyaW0gc3RyaW5nIHZhbHVlcyBvZiB0YWcgYW5kIGF0dHJpYnV0ZXNcbiAgICBjZGF0YVByb3BOYW1lOiBmYWxzZSxcbiAgICBudW1iZXJQYXJzZU9wdGlvbnM6IHtcbiAgICAgIGhleDogdHJ1ZSxcbiAgICAgIGxlYWRpbmdaZXJvczogdHJ1ZSxcbiAgICAgIGVOb3RhdGlvbjogdHJ1ZVxuICAgIH0sXG4gICAgdGFnVmFsdWVQcm9jZXNzb3I6IGZ1bmN0aW9uKHRhZ05hbWUsIHZhbCkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuICAgIGF0dHJpYnV0ZVZhbHVlUHJvY2Vzc29yOiBmdW5jdGlvbihhdHRyTmFtZSwgdmFsKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0sXG4gICAgc3RvcE5vZGVzOiBbXSwgLy9uZXN0ZWQgdGFncyB3aWxsIG5vdCBiZSBwYXJzZWQgZXZlbiBmb3IgZXJyb3JzXG4gICAgYWx3YXlzQ3JlYXRlVGV4dE5vZGU6IGZhbHNlLFxuICAgIGlzQXJyYXk6ICgpID0+IGZhbHNlLFxuICAgIGNvbW1lbnRQcm9wTmFtZTogZmFsc2UsXG4gICAgdW5wYWlyZWRUYWdzOiBbXSxcbiAgICBwcm9jZXNzRW50aXRpZXM6IHRydWUsXG4gICAgaHRtbEVudGl0aWVzOiBmYWxzZSxcbiAgICBpZ25vcmVEZWNsYXJhdGlvbjogZmFsc2UsXG4gICAgaWdub3JlUGlUYWdzOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1UYWdOYW1lOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lOiBmYWxzZSxcbiAgICB1cGRhdGVUYWc6IGZ1bmN0aW9uKHRhZ05hbWUsIGpQYXRoLCBhdHRycyl7XG4gICAgICByZXR1cm4gdGFnTmFtZVxuICAgIH0sXG4gICAgLy8gc2tpcEVtcHR5TGlzdEl0ZW06IGZhbHNlXG4gICAgY2FwdHVyZU1ldGFEYXRhOiBmYWxzZSxcbn07XG4gICBcbmV4cG9ydCBjb25zdCBidWlsZE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbn07XG4iXSwibmFtZXMiOlsiZGVmYXVsdE9wdGlvbnMiLCJwcmVzZXJ2ZU9yZGVyIiwiYXR0cmlidXRlTmFtZVByZWZpeCIsImF0dHJpYnV0ZXNHcm91cE5hbWUiLCJ0ZXh0Tm9kZU5hbWUiLCJpZ25vcmVBdHRyaWJ1dGVzIiwicmVtb3ZlTlNQcmVmaXgiLCJhbGxvd0Jvb2xlYW5BdHRyaWJ1dGVzIiwicGFyc2VUYWdWYWx1ZSIsInBhcnNlQXR0cmlidXRlVmFsdWUiLCJ0cmltVmFsdWVzIiwiY2RhdGFQcm9wTmFtZSIsIm51bWJlclBhcnNlT3B0aW9ucyIsImhleCIsImxlYWRpbmdaZXJvcyIsImVOb3RhdGlvbiIsInRhZ1ZhbHVlUHJvY2Vzc29yIiwidGFnTmFtZSIsInZhbCIsImF0dHJpYnV0ZVZhbHVlUHJvY2Vzc29yIiwiYXR0ck5hbWUiLCJzdG9wTm9kZXMiLCJhbHdheXNDcmVhdGVUZXh0Tm9kZSIsImlzQXJyYXkiLCJjb21tZW50UHJvcE5hbWUiLCJ1bnBhaXJlZFRhZ3MiLCJwcm9jZXNzRW50aXRpZXMiLCJodG1sRW50aXRpZXMiLCJpZ25vcmVEZWNsYXJhdGlvbiIsImlnbm9yZVBpVGFncyIsInRyYW5zZm9ybVRhZ05hbWUiLCJ0cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lIiwidXBkYXRlVGFnIiwialBhdGgiLCJhdHRycyIsImNhcHR1cmVNZXRhRGF0YSIsImJ1aWxkT3B0aW9ucyIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js":
/*!*************************************************************************!*\
  !*** ../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ OrderedObjParser)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ \"(rsc)/../node_modules/fast-xml-parser/src/util.js\");\n/* harmony import */ var _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./xmlNode.js */ \"(rsc)/../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\");\n/* harmony import */ var _DocTypeReader_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DocTypeReader.js */ \"(rsc)/../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js\");\n/* harmony import */ var strnum__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! strnum */ \"(rsc)/../node_modules/strnum/strnum.js\");\n/* harmony import */ var _ignoreAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ignoreAttributes.js */ \"(rsc)/../node_modules/fast-xml-parser/src/ignoreAttributes.js\");\n\n///@ts-check\n\n\n\n\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\nclass OrderedObjParser {\n    constructor(options){\n        this.options = options;\n        this.currentNode = null;\n        this.tagsNodeStack = [];\n        this.docTypeEntities = {};\n        this.lastEntities = {\n            \"apos\": {\n                regex: /&(apos|#39|#x27);/g,\n                val: \"'\"\n            },\n            \"gt\": {\n                regex: /&(gt|#62|#x3E);/g,\n                val: \">\"\n            },\n            \"lt\": {\n                regex: /&(lt|#60|#x3C);/g,\n                val: \"<\"\n            },\n            \"quot\": {\n                regex: /&(quot|#34|#x22);/g,\n                val: '\"'\n            }\n        };\n        this.ampEntity = {\n            regex: /&(amp|#38|#x26);/g,\n            val: \"&\"\n        };\n        this.htmlEntities = {\n            \"space\": {\n                regex: /&(nbsp|#160);/g,\n                val: \" \"\n            },\n            // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n            // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n            // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n            // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n            // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n            \"cent\": {\n                regex: /&(cent|#162);/g,\n                val: \"\\xa2\"\n            },\n            \"pound\": {\n                regex: /&(pound|#163);/g,\n                val: \"\\xa3\"\n            },\n            \"yen\": {\n                regex: /&(yen|#165);/g,\n                val: \"\\xa5\"\n            },\n            \"euro\": {\n                regex: /&(euro|#8364);/g,\n                val: \"\"\n            },\n            \"copyright\": {\n                regex: /&(copy|#169);/g,\n                val: \"\\xa9\"\n            },\n            \"reg\": {\n                regex: /&(reg|#174);/g,\n                val: \"\\xae\"\n            },\n            \"inr\": {\n                regex: /&(inr|#8377);/g,\n                val: \"\"\n            },\n            \"num_dec\": {\n                regex: /&#([0-9]{1,7});/g,\n                val: (_, str)=>String.fromCodePoint(Number.parseInt(str, 10))\n            },\n            \"num_hex\": {\n                regex: /&#x([0-9a-fA-F]{1,6});/g,\n                val: (_, str)=>String.fromCodePoint(Number.parseInt(str, 16))\n            }\n        };\n        this.addExternalEntities = addExternalEntities;\n        this.parseXml = parseXml;\n        this.parseTextData = parseTextData;\n        this.resolveNameSpace = resolveNameSpace;\n        this.buildAttributesMap = buildAttributesMap;\n        this.isItStopNode = isItStopNode;\n        this.replaceEntitiesValue = replaceEntitiesValue;\n        this.readStopNodeData = readStopNodeData;\n        this.saveTextToParentTag = saveTextToParentTag;\n        this.addChild = addChild;\n        this.ignoreAttributesFn = (0,_ignoreAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this.options.ignoreAttributes);\n    }\n}\nfunction addExternalEntities(externalEntities) {\n    const entKeys = Object.keys(externalEntities);\n    for(let i = 0; i < entKeys.length; i++){\n        const ent = entKeys[i];\n        this.lastEntities[ent] = {\n            regex: new RegExp(\"&\" + ent + \";\", \"g\"),\n            val: externalEntities[ent]\n        };\n    }\n}\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */ function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n    if (val !== undefined) {\n        if (this.options.trimValues && !dontTrim) {\n            val = val.trim();\n        }\n        if (val.length > 0) {\n            if (!escapeEntities) val = this.replaceEntitiesValue(val);\n            const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n            if (newval === null || newval === undefined) {\n                //don't parse\n                return val;\n            } else if (typeof newval !== typeof val || newval !== val) {\n                //overwrite\n                return newval;\n            } else if (this.options.trimValues) {\n                return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n            } else {\n                const trimmedVal = val.trim();\n                if (trimmedVal === val) {\n                    return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n                } else {\n                    return val;\n                }\n            }\n        }\n    }\n}\nfunction resolveNameSpace(tagname) {\n    if (this.options.removeNSPrefix) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])([\\\\s\\\\S]*?)\\\\3)?\", \"gm\");\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n    if (this.options.ignoreAttributes !== true && typeof attrStr === \"string\") {\n        // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n        //attrStr = attrStr || attrStr.trim();\n        const matches = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.getAllMatches)(attrStr, attrsRegx);\n        const len = matches.length; //don't make it inline\n        const attrs = {};\n        for(let i = 0; i < len; i++){\n            const attrName = this.resolveNameSpace(matches[i][1]);\n            if (this.ignoreAttributesFn(attrName, jPath)) {\n                continue;\n            }\n            let oldVal = matches[i][4];\n            let aName = this.options.attributeNamePrefix + attrName;\n            if (attrName.length) {\n                if (this.options.transformAttributeName) {\n                    aName = this.options.transformAttributeName(aName);\n                }\n                if (aName === \"__proto__\") aName = \"#__proto__\";\n                if (oldVal !== undefined) {\n                    if (this.options.trimValues) {\n                        oldVal = oldVal.trim();\n                    }\n                    oldVal = this.replaceEntitiesValue(oldVal);\n                    const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n                    if (newVal === null || newVal === undefined) {\n                        //don't parse\n                        attrs[aName] = oldVal;\n                    } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {\n                        //overwrite\n                        attrs[aName] = newVal;\n                    } else {\n                        //parse\n                        attrs[aName] = parseValue(oldVal, this.options.parseAttributeValue, this.options.numberParseOptions);\n                    }\n                } else if (this.options.allowBooleanAttributes) {\n                    attrs[aName] = true;\n                }\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (this.options.attributesGroupName) {\n            const attrCollection = {};\n            attrCollection[this.options.attributesGroupName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\nconst parseXml = function(xmlData) {\n    xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n    const xmlObj = new _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\"!xml\");\n    let currentNode = xmlObj;\n    let textData = \"\";\n    let jPath = \"\";\n    for(let i = 0; i < xmlData.length; i++){\n        const ch = xmlData[i];\n        if (ch === \"<\") {\n            // const nextIndex = i+1;\n            // const _2ndChar = xmlData[nextIndex];\n            if (xmlData[i + 1] === \"/\") {\n                const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\");\n                let tagName = xmlData.substring(i + 2, closeIndex).trim();\n                if (this.options.removeNSPrefix) {\n                    const colonIndex = tagName.indexOf(\":\");\n                    if (colonIndex !== -1) {\n                        tagName = tagName.substr(colonIndex + 1);\n                    }\n                }\n                if (this.options.transformTagName) {\n                    tagName = this.options.transformTagName(tagName);\n                }\n                if (currentNode) {\n                    textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                }\n                //check if last tag of nested tag was unpaired tag\n                const lastTagName = jPath.substring(jPath.lastIndexOf(\".\") + 1);\n                if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {\n                    throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n                }\n                let propIndex = 0;\n                if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {\n                    propIndex = jPath.lastIndexOf(\".\", jPath.lastIndexOf(\".\") - 1);\n                    this.tagsNodeStack.pop();\n                } else {\n                    propIndex = jPath.lastIndexOf(\".\");\n                }\n                jPath = jPath.substring(0, propIndex);\n                currentNode = this.tagsNodeStack.pop(); //avoid recursion, set the parent tag scope\n                textData = \"\";\n                i = closeIndex;\n            } else if (xmlData[i + 1] === \"?\") {\n                let tagData = readTagExp(xmlData, i, false, \"?>\");\n                if (!tagData) throw new Error(\"Pi Tag is not closed.\");\n                textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                if (this.options.ignoreDeclaration && tagData.tagName === \"?xml\" || this.options.ignorePiTags) {} else {\n                    const childNode = new _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tagData.tagName);\n                    childNode.add(this.options.textNodeName, \"\");\n                    if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {\n                        childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n                    }\n                    this.addChild(currentNode, childNode, jPath, i);\n                }\n                i = tagData.closeIndex + 1;\n            } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n                const endIndex = findClosingIndex(xmlData, \"-->\", i + 4, \"Comment is not closed.\");\n                if (this.options.commentPropName) {\n                    const comment = xmlData.substring(i + 4, endIndex - 2);\n                    textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                    currentNode.add(this.options.commentPropName, [\n                        {\n                            [this.options.textNodeName]: comment\n                        }\n                    ]);\n                }\n                i = endIndex;\n            } else if (xmlData.substr(i + 1, 2) === \"!D\") {\n                const result = (0,_DocTypeReader_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(xmlData, i);\n                this.docTypeEntities = result.entities;\n                i = result.i;\n            } else if (xmlData.substr(i + 1, 2) === \"![\") {\n                const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n                const tagExp = xmlData.substring(i + 9, closeIndex);\n                textData = this.saveTextToParentTag(textData, currentNode, jPath);\n                let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n                if (val == undefined) val = \"\";\n                //cdata should be set even if it is 0 length string\n                if (this.options.cdataPropName) {\n                    currentNode.add(this.options.cdataPropName, [\n                        {\n                            [this.options.textNodeName]: tagExp\n                        }\n                    ]);\n                } else {\n                    currentNode.add(this.options.textNodeName, val);\n                }\n                i = closeIndex + 2;\n            } else {\n                let result = readTagExp(xmlData, i, this.options.removeNSPrefix);\n                let tagName = result.tagName;\n                const rawTagName = result.rawTagName;\n                let tagExp = result.tagExp;\n                let attrExpPresent = result.attrExpPresent;\n                let closeIndex = result.closeIndex;\n                if (this.options.transformTagName) {\n                    tagName = this.options.transformTagName(tagName);\n                }\n                //save text as child node\n                if (currentNode && textData) {\n                    if (currentNode.tagname !== \"!xml\") {\n                        //when nested tag is found\n                        textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n                    }\n                }\n                //check if last tag was unpaired tag\n                const lastTag = currentNode;\n                if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {\n                    currentNode = this.tagsNodeStack.pop();\n                    jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n                }\n                if (tagName !== xmlObj.tagname) {\n                    jPath += jPath ? \".\" + tagName : tagName;\n                }\n                const startIndex = i;\n                if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n                    let tagContent = \"\";\n                    //self-closing tag\n                    if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                        if (tagName[tagName.length - 1] === \"/\") {\n                            tagName = tagName.substr(0, tagName.length - 1);\n                            jPath = jPath.substr(0, jPath.length - 1);\n                            tagExp = tagName;\n                        } else {\n                            tagExp = tagExp.substr(0, tagExp.length - 1);\n                        }\n                        i = result.closeIndex;\n                    } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {\n                        i = result.closeIndex;\n                    } else {\n                        //read until closing tag is found\n                        const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n                        if (!result) throw new Error(`Unexpected end of ${rawTagName}`);\n                        i = result.i;\n                        tagContent = result.tagContent;\n                    }\n                    const childNode = new _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tagName);\n                    if (tagName !== tagExp && attrExpPresent) {\n                        childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                    }\n                    if (tagContent) {\n                        tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n                    }\n                    jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n                    childNode.add(this.options.textNodeName, tagContent);\n                    this.addChild(currentNode, childNode, jPath, startIndex);\n                } else {\n                    //selfClosing tag\n                    if (tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) {\n                        if (tagName[tagName.length - 1] === \"/\") {\n                            tagName = tagName.substr(0, tagName.length - 1);\n                            jPath = jPath.substr(0, jPath.length - 1);\n                            tagExp = tagName;\n                        } else {\n                            tagExp = tagExp.substr(0, tagExp.length - 1);\n                        }\n                        if (this.options.transformTagName) {\n                            tagName = this.options.transformTagName(tagName);\n                        }\n                        const childNode = new _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tagName);\n                        if (tagName !== tagExp && attrExpPresent) {\n                            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                        }\n                        this.addChild(currentNode, childNode, jPath, startIndex);\n                        jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n                    } else {\n                        const childNode = new _xmlNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](tagName);\n                        this.tagsNodeStack.push(currentNode);\n                        if (tagName !== tagExp && attrExpPresent) {\n                            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n                        }\n                        this.addChild(currentNode, childNode, jPath, startIndex);\n                        currentNode = childNode;\n                    }\n                    textData = \"\";\n                    i = closeIndex;\n                }\n            }\n        } else {\n            textData += xmlData[i];\n        }\n    }\n    return xmlObj.child;\n};\nfunction addChild(currentNode, childNode, jPath, startIndex) {\n    // unset startIndex if not requested\n    if (!this.options.captureMetaData) startIndex = undefined;\n    const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"]);\n    if (result === false) {} else if (typeof result === \"string\") {\n        childNode.tagname = result;\n        currentNode.addChild(childNode, startIndex);\n    } else {\n        currentNode.addChild(childNode, startIndex);\n    }\n}\nconst replaceEntitiesValue = function(val) {\n    if (this.options.processEntities) {\n        for(let entityName in this.docTypeEntities){\n            const entity = this.docTypeEntities[entityName];\n            val = val.replace(entity.regx, entity.val);\n        }\n        for(let entityName in this.lastEntities){\n            const entity = this.lastEntities[entityName];\n            val = val.replace(entity.regex, entity.val);\n        }\n        if (this.options.htmlEntities) {\n            for(let entityName in this.htmlEntities){\n                const entity = this.htmlEntities[entityName];\n                val = val.replace(entity.regex, entity.val);\n            }\n        }\n        val = val.replace(this.ampEntity.regex, this.ampEntity.val);\n    }\n    return val;\n};\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n    if (textData) {\n        if (isLeafNode === undefined) isLeafNode = currentNode.child.length === 0;\n        textData = this.parseTextData(textData, currentNode.tagname, jPath, false, currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false, isLeafNode);\n        if (textData !== undefined && textData !== \"\") currentNode.add(this.options.textNodeName, textData);\n        textData = \"\";\n    }\n    return textData;\n}\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */ function isItStopNode(stopNodes, jPath, currentTagName) {\n    const allNodesExp = \"*.\" + currentTagName;\n    for(const stopNodePath in stopNodes){\n        const stopNodeExp = stopNodes[stopNodePath];\n        if (allNodesExp === stopNodeExp || jPath === stopNodeExp) return true;\n    }\n    return false;\n}\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */ function tagExpWithClosingIndex(xmlData, i, closingChar = \">\") {\n    let attrBoundary;\n    let tagExp = \"\";\n    for(let index = i; index < xmlData.length; index++){\n        let ch = xmlData[index];\n        if (attrBoundary) {\n            if (ch === attrBoundary) attrBoundary = \"\"; //reset\n        } else if (ch === '\"' || ch === \"'\") {\n            attrBoundary = ch;\n        } else if (ch === closingChar[0]) {\n            if (closingChar[1]) {\n                if (xmlData[index + 1] === closingChar[1]) {\n                    return {\n                        data: tagExp,\n                        index: index\n                    };\n                }\n            } else {\n                return {\n                    data: tagExp,\n                    index: index\n                };\n            }\n        } else if (ch === \"\t\") {\n            ch = \" \";\n        }\n        tagExp += ch;\n    }\n}\nfunction findClosingIndex(xmlData, str, i, errMsg) {\n    const closingIndex = xmlData.indexOf(str, i);\n    if (closingIndex === -1) {\n        throw new Error(errMsg);\n    } else {\n        return closingIndex + str.length - 1;\n    }\n}\nfunction readTagExp(xmlData, i, removeNSPrefix, closingChar = \">\") {\n    const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);\n    if (!result) return;\n    let tagExp = result.data;\n    const closeIndex = result.index;\n    const separatorIndex = tagExp.search(/\\s/);\n    let tagName = tagExp;\n    let attrExpPresent = true;\n    if (separatorIndex !== -1) {\n        tagName = tagExp.substring(0, separatorIndex);\n        tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n    }\n    const rawTagName = tagName;\n    if (removeNSPrefix) {\n        const colonIndex = tagName.indexOf(\":\");\n        if (colonIndex !== -1) {\n            tagName = tagName.substr(colonIndex + 1);\n            attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n        }\n    }\n    return {\n        tagName: tagName,\n        tagExp: tagExp,\n        closeIndex: closeIndex,\n        attrExpPresent: attrExpPresent,\n        rawTagName: rawTagName\n    };\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */ function readStopNodeData(xmlData, tagName, i) {\n    const startIndex = i;\n    // Starting at 1 since we already have an open tag\n    let openTagCount = 1;\n    for(; i < xmlData.length; i++){\n        if (xmlData[i] === \"<\") {\n            if (xmlData[i + 1] === \"/\") {\n                const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n                let closeTagName = xmlData.substring(i + 2, closeIndex).trim();\n                if (closeTagName === tagName) {\n                    openTagCount--;\n                    if (openTagCount === 0) {\n                        return {\n                            tagContent: xmlData.substring(startIndex, i),\n                            i: closeIndex\n                        };\n                    }\n                }\n                i = closeIndex;\n            } else if (xmlData[i + 1] === \"?\") {\n                const closeIndex = findClosingIndex(xmlData, \"?>\", i + 1, \"StopNode is not closed.\");\n                i = closeIndex;\n            } else if (xmlData.substr(i + 1, 3) === \"!--\") {\n                const closeIndex = findClosingIndex(xmlData, \"-->\", i + 3, \"StopNode is not closed.\");\n                i = closeIndex;\n            } else if (xmlData.substr(i + 1, 2) === \"![\") {\n                const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n                i = closeIndex;\n            } else {\n                const tagData = readTagExp(xmlData, i, \">\");\n                if (tagData) {\n                    const openTagName = tagData && tagData.tagName;\n                    if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== \"/\") {\n                        openTagCount++;\n                    }\n                    i = tagData.closeIndex;\n                }\n            }\n        }\n    } //end for loop\n}\nfunction parseValue(val, shouldParse, options) {\n    if (shouldParse && typeof val === \"string\") {\n        //console.log(options)\n        const newval = val.trim();\n        if (newval === \"true\") return true;\n        else if (newval === \"false\") return false;\n        else return (0,strnum__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(val, options);\n    } else {\n        if ((0,_util_js__WEBPACK_IMPORTED_MODULE_2__.isExist)(val)) {\n            return val;\n        } else {\n            return \"\";\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL09yZGVyZWRPYmpQYXJzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQSxZQUFZO0FBRXNDO0FBQ2Y7QUFDVTtBQUNmO0FBQzZCO0FBRTNELGVBQWU7QUFDZiw0RkFBNEY7QUFDNUYsd0NBQXdDO0FBRXhDLDhGQUE4RjtBQUM5RixvSEFBb0g7QUFFckcsTUFBTU07SUFDbkJDLFlBQVlDLE9BQU8sQ0FBQztRQUNsQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLGFBQWEsR0FBRyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLENBQUM7UUFDeEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7WUFDbEIsUUFBUztnQkFBRUMsT0FBTztnQkFBc0JDLEtBQU07WUFBRztZQUNqRCxNQUFPO2dCQUFFRCxPQUFPO2dCQUFvQkMsS0FBTTtZQUFHO1lBQzdDLE1BQU87Z0JBQUVELE9BQU87Z0JBQW9CQyxLQUFNO1lBQUc7WUFDN0MsUUFBUztnQkFBRUQsT0FBTztnQkFBc0JDLEtBQU07WUFBSTtRQUNwRDtRQUNBLElBQUksQ0FBQ0MsU0FBUyxHQUFHO1lBQUVGLE9BQU87WUFBcUJDLEtBQU07UUFBRztRQUN4RCxJQUFJLENBQUNFLFlBQVksR0FBRztZQUNsQixTQUFTO2dCQUFFSCxPQUFPO2dCQUFrQkMsS0FBSztZQUFJO1lBQzdDLDZDQUE2QztZQUM3Qyw2Q0FBNkM7WUFDN0MsK0NBQStDO1lBQy9DLGtEQUFrRDtZQUNsRCxpREFBaUQ7WUFDakQsUUFBUztnQkFBRUQsT0FBTztnQkFBa0JDLEtBQUs7WUFBSTtZQUM3QyxTQUFVO2dCQUFFRCxPQUFPO2dCQUFtQkMsS0FBSztZQUFJO1lBQy9DLE9BQVE7Z0JBQUVELE9BQU87Z0JBQWlCQyxLQUFLO1lBQUk7WUFDM0MsUUFBUztnQkFBRUQsT0FB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QUkyRCxTQUFTO29CQUNYLE1BQU00QyxjQUFjNUMsV0FBV0EsUUFBUXZELE9BQU87b0JBQzlDLElBQUltRyxnQkFBZ0JuRyxXQUFXdUQsUUFBUU8sTUFBTSxDQUFDUCxRQUFRTyxNQUFNLENBQUNqRSxNQUFNLEdBQUMsRUFBRSxLQUFLLEtBQUs7d0JBQzlFb0c7b0JBQ0Y7b0JBQ0FyRyxJQUFFMkQsUUFBUWIsVUFBVTtnQkFDdEI7WUFDRjtRQUNGO0lBQ0osRUFBQyxjQUFjO0FBQ2pCO0FBRUEsU0FBUy9CLFdBQVd4QyxHQUFHLEVBQUVpSSxXQUFXLEVBQUV2SSxPQUFPO0lBQzNDLElBQUl1SSxlQUFlLE9BQU9qSSxRQUFRLFVBQVU7UUFDMUMsc0JBQXNCO1FBQ3RCLE1BQU1zQyxTQUFTdEMsSUFBSXFDLElBQUk7UUFDdkIsSUFBR0MsV0FBVyxRQUFTLE9BQU87YUFDekIsSUFBR0EsV0FBVyxTQUFVLE9BQU87YUFDL0IsT0FBT2hELGtEQUFRQSxDQUFDVSxLQUFLTjtJQUM1QixPQUFPO1FBQ0wsSUFBSVAsaURBQU9BLENBQUNhLE1BQU07WUFDaEIsT0FBT0E7UUFDVCxPQUFPO1lBQ0wsT0FBTztRQUNUO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWRhc2hib2FyZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvT3JkZXJlZE9ialBhcnNlci5qcz9hYzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vL0B0cy1jaGVja1xuXG5pbXBvcnQge2dldEFsbE1hdGNoZXMsIGlzRXhpc3R9IGZyb20gJy4uL3V0aWwuanMnO1xuaW1wb3J0IHhtbE5vZGUgZnJvbSAnLi94bWxOb2RlLmpzJztcbmltcG9ydCByZWFkRG9jVHlwZSBmcm9tICcuL0RvY1R5cGVSZWFkZXIuanMnO1xuaW1wb3J0IHRvTnVtYmVyIGZyb20gXCJzdHJudW1cIjtcbmltcG9ydCBnZXRJZ25vcmVBdHRyaWJ1dGVzRm4gZnJvbSBcIi4uL2lnbm9yZUF0dHJpYnV0ZXMuanNcIjtcblxuLy8gY29uc3QgcmVneCA9XG4vLyAgICc8KCghXFxcXFtDREFUQVxcXFxbKFtcXFxcc1xcXFxTXSo/KShdXT4pKXwoKE5BTUU6KT8oTkFNRSkpKFtePl0qKT58KChcXFxcLykoTkFNRSlcXFxccyo+KSkoW148XSopJ1xuLy8gICAucmVwbGFjZSgvTkFNRS9nLCB1dGlsLm5hbWVSZWdleHApO1xuXG4vL2NvbnN0IHRhZ3NSZWd4ID0gbmV3IFJlZ0V4cChcIjwoXFxcXC8/W1xcXFx3OlxcXFwtXFwuX10rKShbXj5dKik+KFxcXFxzKlwiK2NkYXRhUmVneCtcIikqKFtePF0rKT9cIixcImdcIik7XG4vL2NvbnN0IHRhZ3NSZWd4ID0gbmV3IFJlZ0V4cChcIjwoXFxcXC8/KSgoXFxcXHcqOik/KFtcXFxcdzpcXFxcLVxcLl9dKykpKFtePl0qKT4oW148XSopKFwiK2NkYXRhUmVneCtcIihbXjxdKikpKihbXjxdKyk/XCIsXCJnXCIpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPcmRlcmVkT2JqUGFyc2Vye1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKXtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBudWxsO1xuICAgIHRoaXMudGFnc05vZGVTdGFjayA9IFtdO1xuICAgIHRoaXMuZG9jVHlwZUVudGl0aWVzID0ge307XG4gICAgdGhpcy5sYXN0RW50aXRpZXMgPSB7XG4gICAgICBcImFwb3NcIiA6IHsgcmVnZXg6IC8mKGFwb3N8IzM5fCN4MjcpOy9nLCB2YWwgOiBcIidcIn0sXG4gICAgICBcImd0XCIgOiB7IHJlZ2V4OiAvJihndHwjNjJ8I3gzRSk7L2csIHZhbCA6IFwiPlwifSxcbiAgICAgIFwibHRcIiA6IHsgcmVnZXg6IC8mKGx0fCM2MHwjeDNDKTsvZywgdmFsIDogXCI8XCJ9LFxuICAgICAgXCJxdW90XCIgOiB7IHJlZ2V4OiAvJihxdW90fCMzNHwjeDIyKTsvZywgdmFsIDogXCJcXFwiXCJ9LFxuICAgIH07XG4gICAgdGhpcy5hbXBFbnRpdHkgPSB7IHJlZ2V4OiAvJihhbXB8IzM4fCN4MjYpOy9nLCB2YWwgOiBcIiZcIn07XG4gICAgdGhpcy5odG1sRW50aXRpZXMgPSB7XG4gICAgICBcInNwYWNlXCI6IHsgcmVnZXg6IC8mKG5ic3B8IzE2MCk7L2csIHZhbDogXCIgXCIgfSxcbiAgICAgIC8vIFwibHRcIiA6IHsgcmVnZXg6IC8mKGx0fCM2MCk7L2csIHZhbDogXCI8XCIgfSxcbiAgICAgIC8vIFwiZ3RcIiA6IHsgcmVnZXg6IC8mKGd0fCM2Mik7L2csIHZhbDogXCI+XCIgfSxcbiAgICAgIC8vIFwiYW1wXCIgOiB7IHJlZ2V4OiAvJihhbXB8IzM4KTsvZywgdmFsOiBcIiZcIiB9LFxuICAgICAgLy8gXCJxdW90XCIgOiB7IHJlZ2V4OiAvJihxdW90fCMzNCk7L2csIHZhbDogXCJcXFwiXCIgfSxcbiAgICAgIC8vIFwiYXBvc1wiIDogeyByZWdleDogLyYoYXBvc3wjMzkpOy9nLCB2YWw6IFwiJ1wiIH0sXG4gICAgICBcImNlbnRcIiA6IHsgcmVnZXg6IC8mKGNlbnR8IzE2Mik7L2csIHZhbDogXCLColwiIH0sXG4gICAgICBcInBvdW5kXCIgOiB7IHJlZ2V4OiAvJihwb3VuZHwjMTYzKTsvZywgdmFsOiBcIsKjXCIgfSxcbiAgICAgIFwieWVuXCIgOiB7IHJlZ2V4OiAvJih5ZW58IzE2NSk7L2csIHZhbDogXCLCpVwiIH0sXG4gICAgICBcImV1cm9cIiA6IHsgcmVnZXg6IC8mKGV1cm98IzgzNjQpOy9nLCB2YWw6IFwi4oKsXCIgfSxcbiAgICAgIFwiY29weXJpZ2h0XCIgOiB7IHJlZ2V4OiAvJihjb3B5fCMxNjkpOy9nLCB2YWw6IFwiwqlcIiB9LFxuICAgICAgXCJyZWdcIiA6IHsgcmVnZXg6IC8mKHJlZ3wjMTc0KTsvZywgdmFsOiBcIsKuXCIgfSxcbiAgICAgIFwiaW5yXCIgOiB7IHJlZ2V4OiAvJihpbnJ8IzgzNzcpOy9nLCB2YWw6IFwi4oK5XCIgfSxcbiAgICAgIFwibnVtX2RlY1wiOiB7IHJlZ2V4OiAvJiMoWzAtOV17MSw3fSk7L2csIHZhbCA6IChfLCBzdHIpID0+IFN0cmluZy5mcm9tQ29kZVBvaW50KE51bWJlci5wYXJzZUludChzdHIsIDEwKSkgfSxcbiAgICAgIFwibnVtX2hleFwiOiB7IHJlZ2V4OiAvJiN4KFswLTlhLWZBLUZdezEsNn0pOy9nLCB2YWwgOiAoXywgc3RyKSA9PiBTdHJpbmcuZnJvbUNvZGVQb2ludChOdW1iZXIucGFyc2VJbnQoc3RyLCAxNikpIH0sXG4gICAgfTtcbiAgICB0aGlzLmFkZEV4dGVybmFsRW50aXRpZXMgPSBhZGRFeHRlcm5hbEVudGl0aWVzO1xuICAgIHRoaXMucGFyc2VYbWwgPSBwYXJzZVhtbDtcbiAgICB0aGlzLnBhcnNlVGV4dERhdGEgPSBwYXJzZVRleHREYXRhO1xuICAgIHRoaXMucmVzb2x2ZU5hbWVTcGFjZSA9IHJlc29sdmVOYW1lU3BhY2U7XG4gICAgdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAgPSBidWlsZEF0dHJpYnV0ZXNNYXA7XG4gICAgdGhpcy5pc0l0U3RvcE5vZGUgPSBpc0l0U3RvcE5vZGU7XG4gICAgdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZSA9IHJlcGxhY2VFbnRpdGllc1ZhbHVlO1xuICAgIHRoaXMucmVhZFN0b3BOb2RlRGF0YSA9IHJlYWRTdG9wTm9kZURhdGE7XG4gICAgdGhpcy5zYXZlVGV4dFRvUGFyZW50VGFnID0gc2F2ZVRleHRUb1BhcmVudFRhZztcbiAgICB0aGlzLmFkZENoaWxkID0gYWRkQ2hpbGQ7XG4gICAgdGhpcy5pZ25vcmVBdHRyaWJ1dGVzRm4gPSBnZXRJZ25vcmVBdHRyaWJ1dGVzRm4odGhpcy5vcHRpb25zLmlnbm9yZUF0dHJpYnV0ZXMpXG4gIH1cblxufVxuXG5mdW5jdGlvbiBhZGRFeHRlcm5hbEVudGl0aWVzKGV4dGVybmFsRW50aXRpZXMpe1xuICBjb25zdCBlbnRLZXlzID0gT2JqZWN0LmtleXMoZXh0ZXJuYWxFbnRpdGllcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW50S2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVudCA9IGVudEtleXNbaV07XG4gICAgdGhpcy5sYXN0RW50aXRpZXNbZW50XSA9IHtcbiAgICAgICByZWdleDogbmV3IFJlZ0V4cChcIiZcIitlbnQrXCI7XCIsXCJnXCIpLFxuICAgICAgIHZhbCA6IGV4dGVybmFsRW50aXRpZXNbZW50XVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30galBhdGhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFRyaW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzQXR0cmlidXRlc1xuICogQHBhcmFtIHtib29sZWFufSBpc0xlYWZOb2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY2FwZUVudGl0aWVzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVGV4dERhdGEodmFsLCB0YWdOYW1lLCBqUGF0aCwgZG9udFRyaW0sIGhhc0F0dHJpYnV0ZXMsIGlzTGVhZk5vZGUsIGVzY2FwZUVudGl0aWVzKSB7XG4gIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudHJpbVZhbHVlcyAmJiAhZG9udFRyaW0pIHtcbiAgICAgIHZhbCA9IHZhbC50cmltKCk7XG4gICAgfVxuICAgIGlmKHZhbC5sZW5ndGggPiAwKXtcbiAgICAgIGlmKCFlc2NhcGVFbnRpdGllcykgdmFsID0gdGhpcy5yZXBsYWNlRW50aXRpZXNWYWx1ZSh2YWwpO1xuICAgICAgXG4gICAgICBjb25zdCBuZXd2YWwgPSB0aGlzLm9wdGlvbnMudGFnVmFsdWVQcm9jZXNzb3IodGFnTmFtZSwgdmFsLCBqUGF0aCwgaGFzQXR0cmlidXRlcywgaXNMZWFmTm9kZSk7XG4gICAgICBpZihuZXd2YWwgPT09IG51bGwgfHwgbmV3dmFsID09PSB1bmRlZmluZWQpe1xuICAgICAgICAvL2Rvbid0IHBhcnNlXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9ZWxzZSBpZih0eXBlb2YgbmV3dmFsICE9PSB0eXBlb2YgdmFsIHx8IG5ld3ZhbCAhPT0gdmFsKXtcbiAgICAgICAgLy9vdmVyd3JpdGVcbiAgICAgICAgcmV0dXJuIG5ld3ZhbDtcbiAgICAgIH1lbHNlIGlmKHRoaXMub3B0aW9ucy50cmltVmFsdWVzKXtcbiAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodmFsLCB0aGlzLm9wdGlvbnMucGFyc2VUYWdWYWx1ZSwgdGhpcy5vcHRpb25zLm51bWJlclBhcnNlT3B0aW9ucyk7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgY29uc3QgdHJpbW1lZFZhbCA9IHZhbC50cmltKCk7XG4gICAgICAgIGlmKHRyaW1tZWRWYWwgPT09IHZhbCl7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWUodmFsLCB0aGlzLm9wdGlvbnMucGFyc2VUYWdWYWx1ZSwgdGhpcy5vcHRpb25zLm51bWJlclBhcnNlT3B0aW9ucyk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU5hbWVTcGFjZSh0YWduYW1lKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlTlNQcmVmaXgpIHtcbiAgICBjb25zdCB0YWdzID0gdGFnbmFtZS5zcGxpdCgnOicpO1xuICAgIGNvbnN0IHByZWZpeCA9IHRhZ25hbWUuY2hhckF0KDApID09PSAnLycgPyAnLycgOiAnJztcbiAgICBpZiAodGFnc1swXSA9PT0gJ3htbG5zJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAodGFncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRhZ25hbWUgPSBwcmVmaXggKyB0YWdzWzFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFnbmFtZTtcbn1cblxuLy9UT0RPOiBjaGFuZ2UgcmVnZXggdG8gY2FwdHVyZSBOU1xuLy9jb25zdCBhdHRyc1JlZ3ggPSBuZXcgUmVnRXhwKFwiKFtcXFxcd1xcXFwtXFxcXC5cXFxcOl0rKVxcXFxzKj1cXFxccyooWydcXFwiXSkoKC58XFxuKSo/KVxcXFwyXCIsXCJnbVwiKTtcbmNvbnN0IGF0dHJzUmVneCA9IG5ldyBSZWdFeHAoJyhbXlxcXFxzPV0rKVxcXFxzKig9XFxcXHMqKFtcXCdcIl0pKFtcXFxcc1xcXFxTXSo/KVxcXFwzKT8nLCAnZ20nKTtcblxuZnVuY3Rpb24gYnVpbGRBdHRyaWJ1dGVzTWFwKGF0dHJTdHIsIGpQYXRoLCB0YWdOYW1lKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlQXR0cmlidXRlcyAhPT0gdHJ1ZSAmJiB0eXBlb2YgYXR0clN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBhdHRyU3RyID0gYXR0clN0ci5yZXBsYWNlKC9cXHI/XFxuL2csICcgJyk7XG4gICAgLy9hdHRyU3RyID0gYXR0clN0ciB8fCBhdHRyU3RyLnRyaW0oKTtcblxuICAgIGNvbnN0IG1hdGNoZXMgPSBnZXRBbGxNYXRjaGVzKGF0dHJTdHIsIGF0dHJzUmVneCk7XG4gICAgY29uc3QgbGVuID0gbWF0Y2hlcy5sZW5ndGg7IC8vZG9uJ3QgbWFrZSBpdCBpbmxpbmVcbiAgICBjb25zdCBhdHRycyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5yZXNvbHZlTmFtZVNwYWNlKG1hdGNoZXNbaV1bMV0pO1xuICAgICAgaWYgKHRoaXMuaWdub3JlQXR0cmlidXRlc0ZuKGF0dHJOYW1lLCBqUGF0aCkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxldCBvbGRWYWwgPSBtYXRjaGVzW2ldWzRdO1xuICAgICAgbGV0IGFOYW1lID0gdGhpcy5vcHRpb25zLmF0dHJpYnV0ZU5hbWVQcmVmaXggKyBhdHRyTmFtZTtcbiAgICAgIGlmIChhdHRyTmFtZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgICAgYU5hbWUgPSB0aGlzLm9wdGlvbnMudHJhbnNmb3JtQXR0cmlidXRlTmFtZShhTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoYU5hbWUgPT09IFwiX19wcm90b19fXCIpIGFOYW1lICA9IFwiI19fcHJvdG9fX1wiO1xuICAgICAgICBpZiAob2xkVmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyaW1WYWx1ZXMpIHtcbiAgICAgICAgICAgIG9sZFZhbCA9IG9sZFZhbC50cmltKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9sZFZhbCA9IHRoaXMucmVwbGFjZUVudGl0aWVzVmFsdWUob2xkVmFsKTtcbiAgICAgICAgICBjb25zdCBuZXdWYWwgPSB0aGlzLm9wdGlvbnMuYXR0cmlidXRlVmFsdWVQcm9jZXNzb3IoYXR0ck5hbWUsIG9sZFZhbCwgalBhdGgpO1xuICAgICAgICAgIGlmKG5ld1ZhbCA9PT0gbnVsbCB8fCBuZXdWYWwgPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAvL2Rvbid0IHBhcnNlXG4gICAgICAgICAgICBhdHRyc1thTmFtZV0gPSBvbGRWYWw7XG4gICAgICAgICAgfWVsc2UgaWYodHlwZW9mIG5ld1ZhbCAhPT0gdHlwZW9mIG9sZFZhbCB8fCBuZXdWYWwgIT09IG9sZFZhbCl7XG4gICAgICAgICAgICAvL292ZXJ3cml0ZVxuICAgICAgICAgICAgYXR0cnNbYU5hbWVdID0gbmV3VmFsO1xuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgLy9wYXJzZVxuICAgICAgICAgICAgYXR0cnNbYU5hbWVdID0gcGFyc2VWYWx1ZShcbiAgICAgICAgICAgICAgb2xkVmFsLFxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyc2VBdHRyaWJ1dGVWYWx1ZSxcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm51bWJlclBhcnNlT3B0aW9uc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmFsbG93Qm9vbGVhbkF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyc1thTmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0ZXNHcm91cE5hbWUpIHtcbiAgICAgIGNvbnN0IGF0dHJDb2xsZWN0aW9uID0ge307XG4gICAgICBhdHRyQ29sbGVjdGlvblt0aGlzLm9wdGlvbnMuYXR0cmlidXRlc0dyb3VwTmFtZV0gPSBhdHRycztcbiAgICAgIHJldHVybiBhdHRyQ29sbGVjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzXG4gIH1cbn1cblxuY29uc3QgcGFyc2VYbWwgPSBmdW5jdGlvbih4bWxEYXRhKSB7XG4gIHhtbERhdGEgPSB4bWxEYXRhLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIik7IC8vVE9ETzogcmVtb3ZlIHRoaXMgbGluZVxuICBjb25zdCB4bWxPYmogPSBuZXcgeG1sTm9kZSgnIXhtbCcpO1xuICBsZXQgY3VycmVudE5vZGUgPSB4bWxPYmo7XG4gIGxldCB0ZXh0RGF0YSA9IFwiXCI7XG4gIGxldCBqUGF0aCA9IFwiXCI7XG4gIGZvcihsZXQgaT0wOyBpPCB4bWxEYXRhLmxlbmd0aDsgaSsrKXsvL2ZvciBlYWNoIGNoYXIgaW4gWE1MIGRhdGFcbiAgICBjb25zdCBjaCA9IHhtbERhdGFbaV07XG4gICAgaWYoY2ggPT09ICc8Jyl7XG4gICAgICAvLyBjb25zdCBuZXh0SW5kZXggPSBpKzE7XG4gICAgICAvLyBjb25zdCBfMm5kQ2hhciA9IHhtbERhdGFbbmV4dEluZGV4XTtcbiAgICAgIGlmKCB4bWxEYXRhW2krMV0gPT09ICcvJykgey8vQ2xvc2luZyBUYWdcbiAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCI+XCIsIGksIFwiQ2xvc2luZyBUYWcgaXMgbm90IGNsb3NlZC5cIilcbiAgICAgICAgbGV0IHRhZ05hbWUgPSB4bWxEYXRhLnN1YnN0cmluZyhpKzIsY2xvc2VJbmRleCkudHJpbSgpO1xuXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5yZW1vdmVOU1ByZWZpeCl7XG4gICAgICAgICAgY29uc3QgY29sb25JbmRleCA9IHRhZ05hbWUuaW5kZXhPZihcIjpcIik7XG4gICAgICAgICAgaWYoY29sb25JbmRleCAhPT0gLTEpe1xuICAgICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc3Vic3RyKGNvbG9uSW5kZXgrMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUpIHtcbiAgICAgICAgICB0YWdOYW1lID0gdGhpcy5vcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjdXJyZW50Tm9kZSl7XG4gICAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGlmIGxhc3QgdGFnIG9mIG5lc3RlZCB0YWcgd2FzIHVucGFpcmVkIHRhZ1xuICAgICAgICBjb25zdCBsYXN0VGFnTmFtZSA9IGpQYXRoLnN1YnN0cmluZyhqUGF0aC5sYXN0SW5kZXhPZihcIi5cIikrMSk7XG4gICAgICAgIGlmKHRhZ05hbWUgJiYgdGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKHRhZ05hbWUpICE9PSAtMSApe1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5wYWlyZWQgdGFnIGNhbiBub3QgYmUgdXNlZCBhcyBjbG9zaW5nIHRhZzogPC8ke3RhZ05hbWV9PmApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcm9wSW5kZXggPSAwXG4gICAgICAgIGlmKGxhc3RUYWdOYW1lICYmIHRoaXMub3B0aW9ucy51bnBhaXJlZFRhZ3MuaW5kZXhPZihsYXN0VGFnTmFtZSkgIT09IC0xICl7XG4gICAgICAgICAgcHJvcEluZGV4ID0galBhdGgubGFzdEluZGV4T2YoJy4nLCBqUGF0aC5sYXN0SW5kZXhPZignLicpLTEpXG4gICAgICAgICAgdGhpcy50YWdzTm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBwcm9wSW5kZXggPSBqUGF0aC5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgalBhdGggPSBqUGF0aC5zdWJzdHJpbmcoMCwgcHJvcEluZGV4KTtcblxuICAgICAgICBjdXJyZW50Tm9kZSA9IHRoaXMudGFnc05vZGVTdGFjay5wb3AoKTsvL2F2b2lkIHJlY3Vyc2lvbiwgc2V0IHRoZSBwYXJlbnQgdGFnIHNjb3BlXG4gICAgICAgIHRleHREYXRhID0gXCJcIjtcbiAgICAgICAgaSA9IGNsb3NlSW5kZXg7XG4gICAgICB9IGVsc2UgaWYoIHhtbERhdGFbaSsxXSA9PT0gJz8nKSB7XG5cbiAgICAgICAgbGV0IHRhZ0RhdGEgPSByZWFkVGFnRXhwKHhtbERhdGEsaSwgZmFsc2UsIFwiPz5cIik7XG4gICAgICAgIGlmKCF0YWdEYXRhKSB0aHJvdyBuZXcgRXJyb3IoXCJQaSBUYWcgaXMgbm90IGNsb3NlZC5cIik7XG5cbiAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG4gICAgICAgIGlmKCAodGhpcy5vcHRpb25zLmlnbm9yZURlY2xhcmF0aW9uICYmIHRhZ0RhdGEudGFnTmFtZSA9PT0gXCI/eG1sXCIpIHx8IHRoaXMub3B0aW9ucy5pZ25vcmVQaVRhZ3Mpe1xuXG4gICAgICAgIH1lbHNle1xuICBcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBuZXcgeG1sTm9kZSh0YWdEYXRhLnRhZ05hbWUpO1xuICAgICAgICAgIGNoaWxkTm9kZS5hZGQodGhpcy5vcHRpb25zLnRleHROb2RlTmFtZSwgXCJcIik7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYodGFnRGF0YS50YWdOYW1lICE9PSB0YWdEYXRhLnRhZ0V4cCAmJiB0YWdEYXRhLmF0dHJFeHBQcmVzZW50KXtcbiAgICAgICAgICAgIGNoaWxkTm9kZVtcIjpAXCJdID0gdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAodGFnRGF0YS50YWdFeHAsIGpQYXRoLCB0YWdEYXRhLnRhZ05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFkZENoaWxkKGN1cnJlbnROb2RlLCBjaGlsZE5vZGUsIGpQYXRoLCBpKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaSA9IHRhZ0RhdGEuY2xvc2VJbmRleCArIDE7XG4gICAgICB9IGVsc2UgaWYoeG1sRGF0YS5zdWJzdHIoaSArIDEsIDMpID09PSAnIS0tJykge1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCItLT5cIiwgaSs0LCBcIkNvbW1lbnQgaXMgbm90IGNsb3NlZC5cIilcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSl7XG4gICAgICAgICAgY29uc3QgY29tbWVudCA9IHhtbERhdGEuc3Vic3RyaW5nKGkgKyA0LCBlbmRJbmRleCAtIDIpO1xuXG4gICAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG5cbiAgICAgICAgICBjdXJyZW50Tm9kZS5hZGQodGhpcy5vcHRpb25zLmNvbW1lbnRQcm9wTmFtZSwgWyB7IFt0aGlzLm9wdGlvbnMudGV4dE5vZGVOYW1lXSA6IGNvbW1lbnQgfSBdKTtcbiAgICAgICAgfVxuICAgICAgICBpID0gZW5kSW5kZXg7XG4gICAgICB9IGVsc2UgaWYoIHhtbERhdGEuc3Vic3RyKGkgKyAxLCAyKSA9PT0gJyFEJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkRG9jVHlwZSh4bWxEYXRhLCBpKTtcbiAgICAgICAgdGhpcy5kb2NUeXBlRW50aXRpZXMgPSByZXN1bHQuZW50aXRpZXM7XG4gICAgICAgIGkgPSByZXN1bHQuaTtcbiAgICAgIH1lbHNlIGlmKHhtbERhdGEuc3Vic3RyKGkgKyAxLCAyKSA9PT0gJyFbJykge1xuICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIl1dPlwiLCBpLCBcIkNEQVRBIGlzIG5vdCBjbG9zZWQuXCIpIC0gMjtcbiAgICAgICAgY29uc3QgdGFnRXhwID0geG1sRGF0YS5zdWJzdHJpbmcoaSArIDksY2xvc2VJbmRleCk7XG5cbiAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCk7XG5cbiAgICAgICAgbGV0IHZhbCA9IHRoaXMucGFyc2VUZXh0RGF0YSh0YWdFeHAsIGN1cnJlbnROb2RlLnRhZ25hbWUsIGpQYXRoLCB0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGlmKHZhbCA9PSB1bmRlZmluZWQpIHZhbCA9IFwiXCI7XG5cbiAgICAgICAgLy9jZGF0YSBzaG91bGQgYmUgc2V0IGV2ZW4gaWYgaXQgaXMgMCBsZW5ndGggc3RyaW5nXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5jZGF0YVByb3BOYW1lKXtcbiAgICAgICAgICBjdXJyZW50Tm9kZS5hZGQodGhpcy5vcHRpb25zLmNkYXRhUHJvcE5hbWUsIFsgeyBbdGhpcy5vcHRpb25zLnRleHROb2RlTmFtZV0gOiB0YWdFeHAgfSBdKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGkgPSBjbG9zZUluZGV4ICsgMjtcbiAgICAgIH1lbHNlIHsvL09wZW5pbmcgdGFnXG4gICAgICAgIGxldCByZXN1bHQgPSByZWFkVGFnRXhwKHhtbERhdGEsaSwgdGhpcy5vcHRpb25zLnJlbW92ZU5TUHJlZml4KTtcbiAgICAgICAgbGV0IHRhZ05hbWU9IHJlc3VsdC50YWdOYW1lO1xuICAgICAgICBjb25zdCByYXdUYWdOYW1lID0gcmVzdWx0LnJhd1RhZ05hbWU7XG4gICAgICAgIGxldCB0YWdFeHAgPSByZXN1bHQudGFnRXhwO1xuICAgICAgICBsZXQgYXR0ckV4cFByZXNlbnQgPSByZXN1bHQuYXR0ckV4cFByZXNlbnQ7XG4gICAgICAgIGxldCBjbG9zZUluZGV4ID0gcmVzdWx0LmNsb3NlSW5kZXg7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKSB7XG4gICAgICAgICAgdGFnTmFtZSA9IHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL3NhdmUgdGV4dCBhcyBjaGlsZCBub2RlXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZSAmJiB0ZXh0RGF0YSkge1xuICAgICAgICAgIGlmKGN1cnJlbnROb2RlLnRhZ25hbWUgIT09ICcheG1sJyl7XG4gICAgICAgICAgICAvL3doZW4gbmVzdGVkIHRhZyBpcyBmb3VuZFxuICAgICAgICAgICAgdGV4dERhdGEgPSB0aGlzLnNhdmVUZXh0VG9QYXJlbnRUYWcodGV4dERhdGEsIGN1cnJlbnROb2RlLCBqUGF0aCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgaWYgbGFzdCB0YWcgd2FzIHVucGFpcmVkIHRhZ1xuICAgICAgICBjb25zdCBsYXN0VGFnID0gY3VycmVudE5vZGU7XG4gICAgICAgIGlmKGxhc3RUYWcgJiYgdGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKGxhc3RUYWcudGFnbmFtZSkgIT09IC0xICl7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLnRhZ3NOb2RlU3RhY2sucG9wKCk7XG4gICAgICAgICAgalBhdGggPSBqUGF0aC5zdWJzdHJpbmcoMCwgalBhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0YWdOYW1lICE9PSB4bWxPYmoudGFnbmFtZSl7XG4gICAgICAgICAgalBhdGggKz0galBhdGggPyBcIi5cIiArIHRhZ05hbWUgOiB0YWdOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBpO1xuICAgICAgICBpZiAodGhpcy5pc0l0U3RvcE5vZGUodGhpcy5vcHRpb25zLnN0b3BOb2RlcywgalBhdGgsIHRhZ05hbWUpKSB7XG4gICAgICAgICAgbGV0IHRhZ0NvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgIC8vc2VsZi1jbG9zaW5nIHRhZ1xuICAgICAgICAgIGlmKHRhZ0V4cC5sZW5ndGggPiAwICYmIHRhZ0V4cC5sYXN0SW5kZXhPZihcIi9cIikgPT09IHRhZ0V4cC5sZW5ndGggLSAxKXtcbiAgICAgICAgICAgIGlmKHRhZ05hbWVbdGFnTmFtZS5sZW5ndGggLSAxXSA9PT0gXCIvXCIpeyAvL3JlbW92ZSB0cmFpbGluZyAnLydcbiAgICAgICAgICAgICAgdGFnTmFtZSA9IHRhZ05hbWUuc3Vic3RyKDAsIHRhZ05hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyKDAsIGpQYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICB0YWdFeHAgPSB0YWdOYW1lO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHRhZ0V4cCA9IHRhZ0V4cC5zdWJzdHIoMCwgdGFnRXhwLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9IHJlc3VsdC5jbG9zZUluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL3VucGFpcmVkIHRhZ1xuICAgICAgICAgIGVsc2UgaWYodGhpcy5vcHRpb25zLnVucGFpcmVkVGFncy5pbmRleE9mKHRhZ05hbWUpICE9PSAtMSl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGkgPSByZXN1bHQuY2xvc2VJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9ub3JtYWwgdGFnXG4gICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIC8vcmVhZCB1bnRpbCBjbG9zaW5nIHRhZyBpcyBmb3VuZFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5yZWFkU3RvcE5vZGVEYXRhKHhtbERhdGEsIHJhd1RhZ05hbWUsIGNsb3NlSW5kZXggKyAxKTtcbiAgICAgICAgICAgIGlmKCFyZXN1bHQpIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBlbmQgb2YgJHtyYXdUYWdOYW1lfWApO1xuICAgICAgICAgICAgaSA9IHJlc3VsdC5pO1xuICAgICAgICAgICAgdGFnQ29udGVudCA9IHJlc3VsdC50YWdDb250ZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5ldyB4bWxOb2RlKHRhZ05hbWUpO1xuXG4gICAgICAgICAgaWYodGFnTmFtZSAhPT0gdGFnRXhwICYmIGF0dHJFeHBQcmVzZW50KXtcbiAgICAgICAgICAgIGNoaWxkTm9kZVtcIjpAXCJdID0gdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAodGFnRXhwLCBqUGF0aCwgdGFnTmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRhZ0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHRhZ0NvbnRlbnQgPSB0aGlzLnBhcnNlVGV4dERhdGEodGFnQ29udGVudCwgdGFnTmFtZSwgalBhdGgsIHRydWUsIGF0dHJFeHBQcmVzZW50LCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgalBhdGggPSBqUGF0aC5zdWJzdHIoMCwgalBhdGgubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICAgICAgICBjaGlsZE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIHRhZ0NvbnRlbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoY3VycmVudE5vZGUsIGNoaWxkTm9kZSwgalBhdGgsIHN0YXJ0SW5kZXgpO1xuICAgICAgICB9ZWxzZXtcbiAgLy9zZWxmQ2xvc2luZyB0YWdcbiAgICAgICAgICBpZih0YWdFeHAubGVuZ3RoID4gMCAmJiB0YWdFeHAubGFzdEluZGV4T2YoXCIvXCIpID09PSB0YWdFeHAubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgICBpZih0YWdOYW1lW3RhZ05hbWUubGVuZ3RoIC0gMV0gPT09IFwiL1wiKXsgLy9yZW1vdmUgdHJhaWxpbmcgJy8nXG4gICAgICAgICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnN1YnN0cigwLCB0YWdOYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBqUGF0aCA9IGpQYXRoLnN1YnN0cigwLCBqUGF0aC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgdGFnRXhwID0gdGFnTmFtZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICB0YWdFeHAgPSB0YWdFeHAuc3Vic3RyKDAsIHRhZ0V4cC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRyYW5zZm9ybVRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgdGFnTmFtZSA9IHRoaXMub3B0aW9ucy50cmFuc2Zvcm1UYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBuZXcgeG1sTm9kZSh0YWdOYW1lKTtcbiAgICAgICAgICAgIGlmKHRhZ05hbWUgIT09IHRhZ0V4cCAmJiBhdHRyRXhwUHJlc2VudCl7XG4gICAgICAgICAgICAgIGNoaWxkTm9kZVtcIjpAXCJdID0gdGhpcy5idWlsZEF0dHJpYnV0ZXNNYXAodGFnRXhwLCBqUGF0aCwgdGFnTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKGN1cnJlbnROb2RlLCBjaGlsZE5vZGUsIGpQYXRoLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGpQYXRoID0galBhdGguc3Vic3RyKDAsIGpQYXRoLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gICAgICAgICAgfVxuICAgIC8vb3BlbmluZyB0YWdcbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbmV3IHhtbE5vZGUoIHRhZ05hbWUpO1xuICAgICAgICAgICAgdGhpcy50YWdzTm9kZVN0YWNrLnB1c2goY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0YWdOYW1lICE9PSB0YWdFeHAgJiYgYXR0ckV4cFByZXNlbnQpe1xuICAgICAgICAgICAgICBjaGlsZE5vZGVbXCI6QFwiXSA9IHRoaXMuYnVpbGRBdHRyaWJ1dGVzTWFwKHRhZ0V4cCwgalBhdGgsIHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChjdXJyZW50Tm9kZSwgY2hpbGROb2RlLCBqUGF0aCwgc3RhcnRJbmRleCk7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGNoaWxkTm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dERhdGEgPSBcIlwiO1xuICAgICAgICAgIGkgPSBjbG9zZUluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICB0ZXh0RGF0YSArPSB4bWxEYXRhW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4geG1sT2JqLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBhZGRDaGlsZChjdXJyZW50Tm9kZSwgY2hpbGROb2RlLCBqUGF0aCwgc3RhcnRJbmRleCl7XG4gIC8vIHVuc2V0IHN0YXJ0SW5kZXggaWYgbm90IHJlcXVlc3RlZFxuICBpZiAoIXRoaXMub3B0aW9ucy5jYXB0dXJlTWV0YURhdGEpIHN0YXJ0SW5kZXggPSB1bmRlZmluZWQ7XG4gIGNvbnN0IHJlc3VsdCA9IHRoaXMub3B0aW9ucy51cGRhdGVUYWcoY2hpbGROb2RlLnRhZ25hbWUsIGpQYXRoLCBjaGlsZE5vZGVbXCI6QFwiXSlcbiAgaWYocmVzdWx0ID09PSBmYWxzZSl7XG4gIH0gZWxzZSBpZih0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKXtcbiAgICBjaGlsZE5vZGUudGFnbmFtZSA9IHJlc3VsdFxuICAgIGN1cnJlbnROb2RlLmFkZENoaWxkKGNoaWxkTm9kZSwgc3RhcnRJbmRleCk7XG4gIH1lbHNle1xuICAgIGN1cnJlbnROb2RlLmFkZENoaWxkKGNoaWxkTm9kZSwgc3RhcnRJbmRleCk7XG4gIH1cbn1cblxuY29uc3QgcmVwbGFjZUVudGl0aWVzVmFsdWUgPSBmdW5jdGlvbih2YWwpe1xuXG4gIGlmKHRoaXMub3B0aW9ucy5wcm9jZXNzRW50aXRpZXMpe1xuICAgIGZvcihsZXQgZW50aXR5TmFtZSBpbiB0aGlzLmRvY1R5cGVFbnRpdGllcyl7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmRvY1R5cGVFbnRpdGllc1tlbnRpdHlOYW1lXTtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKCBlbnRpdHkucmVneCwgZW50aXR5LnZhbCk7XG4gICAgfVxuICAgIGZvcihsZXQgZW50aXR5TmFtZSBpbiB0aGlzLmxhc3RFbnRpdGllcyl7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLmxhc3RFbnRpdGllc1tlbnRpdHlOYW1lXTtcbiAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKCBlbnRpdHkucmVnZXgsIGVudGl0eS52YWwpO1xuICAgIH1cbiAgICBpZih0aGlzLm9wdGlvbnMuaHRtbEVudGl0aWVzKXtcbiAgICAgIGZvcihsZXQgZW50aXR5TmFtZSBpbiB0aGlzLmh0bWxFbnRpdGllcyl7XG4gICAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuaHRtbEVudGl0aWVzW2VudGl0eU5hbWVdO1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSggZW50aXR5LnJlZ2V4LCBlbnRpdHkudmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoIHRoaXMuYW1wRW50aXR5LnJlZ2V4LCB0aGlzLmFtcEVudGl0eS52YWwpO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBzYXZlVGV4dFRvUGFyZW50VGFnKHRleHREYXRhLCBjdXJyZW50Tm9kZSwgalBhdGgsIGlzTGVhZk5vZGUpIHtcbiAgaWYgKHRleHREYXRhKSB7IC8vc3RvcmUgcHJldmlvdXNseSBjb2xsZWN0ZWQgZGF0YSBhcyB0ZXh0Tm9kZVxuICAgIGlmKGlzTGVhZk5vZGUgPT09IHVuZGVmaW5lZCkgaXNMZWFmTm9kZSA9IGN1cnJlbnROb2RlLmNoaWxkLmxlbmd0aCA9PT0gMFxuICAgIFxuICAgIHRleHREYXRhID0gdGhpcy5wYXJzZVRleHREYXRhKHRleHREYXRhLFxuICAgICAgY3VycmVudE5vZGUudGFnbmFtZSxcbiAgICAgIGpQYXRoLFxuICAgICAgZmFsc2UsXG4gICAgICBjdXJyZW50Tm9kZVtcIjpAXCJdID8gT2JqZWN0LmtleXMoY3VycmVudE5vZGVbXCI6QFwiXSkubGVuZ3RoICE9PSAwIDogZmFsc2UsXG4gICAgICBpc0xlYWZOb2RlKTtcblxuICAgIGlmICh0ZXh0RGF0YSAhPT0gdW5kZWZpbmVkICYmIHRleHREYXRhICE9PSBcIlwiKVxuICAgICAgY3VycmVudE5vZGUuYWRkKHRoaXMub3B0aW9ucy50ZXh0Tm9kZU5hbWUsIHRleHREYXRhKTtcbiAgICB0ZXh0RGF0YSA9IFwiXCI7XG4gIH1cbiAgcmV0dXJuIHRleHREYXRhO1xufVxuXG4vL1RPRE86IHVzZSBqUGF0aCB0byBzaW1wbGlmeSB0aGUgbG9naWNcbi8qKlxuICogXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBzdG9wTm9kZXMgXG4gKiBAcGFyYW0ge3N0cmluZ30galBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50VGFnTmFtZSBcbiAqL1xuZnVuY3Rpb24gaXNJdFN0b3BOb2RlKHN0b3BOb2RlcywgalBhdGgsIGN1cnJlbnRUYWdOYW1lKXtcbiAgY29uc3QgYWxsTm9kZXNFeHAgPSBcIiouXCIgKyBjdXJyZW50VGFnTmFtZTtcbiAgZm9yIChjb25zdCBzdG9wTm9kZVBhdGggaW4gc3RvcE5vZGVzKSB7XG4gICAgY29uc3Qgc3RvcE5vZGVFeHAgPSBzdG9wTm9kZXNbc3RvcE5vZGVQYXRoXTtcbiAgICBpZiggYWxsTm9kZXNFeHAgPT09IHN0b3BOb2RlRXhwIHx8IGpQYXRoID09PSBzdG9wTm9kZUV4cCAgKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdGFnIEV4cHJlc3Npb24gYW5kIHdoZXJlIGl0IGlzIGVuZGluZyBoYW5kbGluZyBzaW5nbGUtZG91YmxlIHF1b3RlcyBzaXR1YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSB4bWxEYXRhIFxuICogQHBhcmFtIHtudW1iZXJ9IGkgc3RhcnRpbmcgaW5kZXhcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiB0YWdFeHBXaXRoQ2xvc2luZ0luZGV4KHhtbERhdGEsIGksIGNsb3NpbmdDaGFyID0gXCI+XCIpe1xuICBsZXQgYXR0ckJvdW5kYXJ5O1xuICBsZXQgdGFnRXhwID0gXCJcIjtcbiAgZm9yIChsZXQgaW5kZXggPSBpOyBpbmRleCA8IHhtbERhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgbGV0IGNoID0geG1sRGF0YVtpbmRleF07XG4gICAgaWYgKGF0dHJCb3VuZGFyeSkge1xuICAgICAgICBpZiAoY2ggPT09IGF0dHJCb3VuZGFyeSkgYXR0ckJvdW5kYXJ5ID0gXCJcIjsvL3Jlc2V0XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gXCInXCIpIHtcbiAgICAgICAgYXR0ckJvdW5kYXJ5ID0gY2g7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gY2xvc2luZ0NoYXJbMF0pIHtcbiAgICAgIGlmKGNsb3NpbmdDaGFyWzFdKXtcbiAgICAgICAgaWYoeG1sRGF0YVtpbmRleCArIDFdID09PSBjbG9zaW5nQ2hhclsxXSl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHRhZ0V4cCxcbiAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGF0YTogdGFnRXhwLFxuICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcdCcpIHtcbiAgICAgIGNoID0gXCIgXCJcbiAgICB9XG4gICAgdGFnRXhwICs9IGNoO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgc3RyLCBpLCBlcnJNc2cpe1xuICBjb25zdCBjbG9zaW5nSW5kZXggPSB4bWxEYXRhLmluZGV4T2Yoc3RyLCBpKTtcbiAgaWYoY2xvc2luZ0luZGV4ID09PSAtMSl7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZylcbiAgfWVsc2V7XG4gICAgcmV0dXJuIGNsb3NpbmdJbmRleCArIHN0ci5sZW5ndGggLSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRUYWdFeHAoeG1sRGF0YSxpLCByZW1vdmVOU1ByZWZpeCwgY2xvc2luZ0NoYXIgPSBcIj5cIil7XG4gIGNvbnN0IHJlc3VsdCA9IHRhZ0V4cFdpdGhDbG9zaW5nSW5kZXgoeG1sRGF0YSwgaSsxLCBjbG9zaW5nQ2hhcik7XG4gIGlmKCFyZXN1bHQpIHJldHVybjtcbiAgbGV0IHRhZ0V4cCA9IHJlc3VsdC5kYXRhO1xuICBjb25zdCBjbG9zZUluZGV4ID0gcmVzdWx0LmluZGV4O1xuICBjb25zdCBzZXBhcmF0b3JJbmRleCA9IHRhZ0V4cC5zZWFyY2goL1xccy8pO1xuICBsZXQgdGFnTmFtZSA9IHRhZ0V4cDtcbiAgbGV0IGF0dHJFeHBQcmVzZW50ID0gdHJ1ZTtcbiAgaWYoc2VwYXJhdG9ySW5kZXggIT09IC0xKXsvL3NlcGFyYXRlIHRhZyBuYW1lIGFuZCBhdHRyaWJ1dGVzIGV4cHJlc3Npb25cbiAgICB0YWdOYW1lID0gdGFnRXhwLnN1YnN0cmluZygwLCBzZXBhcmF0b3JJbmRleCk7XG4gICAgdGFnRXhwID0gdGFnRXhwLnN1YnN0cmluZyhzZXBhcmF0b3JJbmRleCArIDEpLnRyaW1TdGFydCgpO1xuICB9XG5cbiAgY29uc3QgcmF3VGFnTmFtZSA9IHRhZ05hbWU7XG4gIGlmKHJlbW92ZU5TUHJlZml4KXtcbiAgICBjb25zdCBjb2xvbkluZGV4ID0gdGFnTmFtZS5pbmRleE9mKFwiOlwiKTtcbiAgICBpZihjb2xvbkluZGV4ICE9PSAtMSl7XG4gICAgICB0YWdOYW1lID0gdGFnTmFtZS5zdWJzdHIoY29sb25JbmRleCsxKTtcbiAgICAgIGF0dHJFeHBQcmVzZW50ID0gdGFnTmFtZSAhPT0gcmVzdWx0LmRhdGEuc3Vic3RyKGNvbG9uSW5kZXggKyAxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRhZ05hbWU6IHRhZ05hbWUsXG4gICAgdGFnRXhwOiB0YWdFeHAsXG4gICAgY2xvc2VJbmRleDogY2xvc2VJbmRleCxcbiAgICBhdHRyRXhwUHJlc2VudDogYXR0ckV4cFByZXNlbnQsXG4gICAgcmF3VGFnTmFtZTogcmF3VGFnTmFtZSxcbiAgfVxufVxuLyoqXG4gKiBmaW5kIHBhaXJlZCB0YWcgZm9yIGEgc3RvcCBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRGF0YSBcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIFxuICogQHBhcmFtIHtudW1iZXJ9IGkgXG4gKi9cbmZ1bmN0aW9uIHJlYWRTdG9wTm9kZURhdGEoeG1sRGF0YSwgdGFnTmFtZSwgaSl7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpO1xuICAvLyBTdGFydGluZyBhdCAxIHNpbmNlIHdlIGFscmVhZHkgaGF2ZSBhbiBvcGVuIHRhZ1xuICBsZXQgb3BlblRhZ0NvdW50ID0gMTtcblxuICBmb3IgKDsgaSA8IHhtbERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiggeG1sRGF0YVtpXSA9PT0gXCI8XCIpeyBcbiAgICAgIGlmICh4bWxEYXRhW2krMV0gPT09IFwiL1wiKSB7Ly9jbG9zZSB0YWdcbiAgICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIj5cIiwgaSwgYCR7dGFnTmFtZX0gaXMgbm90IGNsb3NlZGApO1xuICAgICAgICAgIGxldCBjbG9zZVRhZ05hbWUgPSB4bWxEYXRhLnN1YnN0cmluZyhpKzIsY2xvc2VJbmRleCkudHJpbSgpO1xuICAgICAgICAgIGlmKGNsb3NlVGFnTmFtZSA9PT0gdGFnTmFtZSl7XG4gICAgICAgICAgICBvcGVuVGFnQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChvcGVuVGFnQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YWdDb250ZW50OiB4bWxEYXRhLnN1YnN0cmluZyhzdGFydEluZGV4LCBpKSxcbiAgICAgICAgICAgICAgICBpIDogY2xvc2VJbmRleFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGk9Y2xvc2VJbmRleDtcbiAgICAgICAgfSBlbHNlIGlmKHhtbERhdGFbaSsxXSA9PT0gJz8nKSB7IFxuICAgICAgICAgIGNvbnN0IGNsb3NlSW5kZXggPSBmaW5kQ2xvc2luZ0luZGV4KHhtbERhdGEsIFwiPz5cIiwgaSsxLCBcIlN0b3BOb2RlIGlzIG5vdCBjbG9zZWQuXCIpXG4gICAgICAgICAgaT1jbG9zZUluZGV4O1xuICAgICAgICB9IGVsc2UgaWYoeG1sRGF0YS5zdWJzdHIoaSArIDEsIDMpID09PSAnIS0tJykgeyBcbiAgICAgICAgICBjb25zdCBjbG9zZUluZGV4ID0gZmluZENsb3NpbmdJbmRleCh4bWxEYXRhLCBcIi0tPlwiLCBpKzMsIFwiU3RvcE5vZGUgaXMgbm90IGNsb3NlZC5cIilcbiAgICAgICAgICBpPWNsb3NlSW5kZXg7XG4gICAgICAgIH0gZWxzZSBpZih4bWxEYXRhLnN1YnN0cihpICsgMSwgMikgPT09ICchWycpIHsgXG4gICAgICAgICAgY29uc3QgY2xvc2VJbmRleCA9IGZpbmRDbG9zaW5nSW5kZXgoeG1sRGF0YSwgXCJdXT5cIiwgaSwgXCJTdG9wTm9kZSBpcyBub3QgY2xvc2VkLlwiKSAtIDI7XG4gICAgICAgICAgaT1jbG9zZUluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRhZ0RhdGEgPSByZWFkVGFnRXhwKHhtbERhdGEsIGksICc+JylcblxuICAgICAgICAgIGlmICh0YWdEYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVuVGFnTmFtZSA9IHRhZ0RhdGEgJiYgdGFnRGF0YS50YWdOYW1lO1xuICAgICAgICAgICAgaWYgKG9wZW5UYWdOYW1lID09PSB0YWdOYW1lICYmIHRhZ0RhdGEudGFnRXhwW3RhZ0RhdGEudGFnRXhwLmxlbmd0aC0xXSAhPT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgb3BlblRhZ0NvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpPXRhZ0RhdGEuY2xvc2VJbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfS8vZW5kIGZvciBsb29wXG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsLCBzaG91bGRQYXJzZSwgb3B0aW9ucykge1xuICBpZiAoc2hvdWxkUGFyc2UgJiYgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAvL2NvbnNvbGUubG9nKG9wdGlvbnMpXG4gICAgY29uc3QgbmV3dmFsID0gdmFsLnRyaW0oKTtcbiAgICBpZihuZXd2YWwgPT09ICd0cnVlJyApIHJldHVybiB0cnVlO1xuICAgIGVsc2UgaWYobmV3dmFsID09PSAnZmFsc2UnICkgcmV0dXJuIGZhbHNlO1xuICAgIGVsc2UgcmV0dXJuIHRvTnVtYmVyKHZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzRXhpc3QodmFsKSkge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbImdldEFsbE1hdGNoZXMiLCJpc0V4aXN0IiwieG1sTm9kZSIsInJlYWREb2NUeXBlIiwidG9OdW1iZXIiLCJnZXRJZ25vcmVBdHRyaWJ1dGVzRm4iLCJPcmRlcmVkT2JqUGFyc2VyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiY3VycmVudE5vZGUiLCJ0YWdzTm9kZVN0YWNrIiwiZG9jVHlwZUVudGl0aWVzIiwibGFzdEVudGl0aWVzIiwicmVnZXgiLCJ2YWwiLCJhbXBFbnRpdHkiLCJodG1sRW50aXRpZXMiLCJfIiwic3RyIiwiU3RyaW5nIiwiZnJvbUNvZGVQb2ludCIsIk51bWJlciIsInBhcnNlSW50IiwiYWRkRXh0ZXJuYWxFbnRpdGllcyIsInBhcnNlWG1sIiwicGFyc2VUZXh0RGF0YSIsInJlc29sdmVOYW1lU3BhY2UiLCJidWlsZEF0dHJpYnV0ZXNNYXAiLCJpc0l0U3RvcE5vZGUiLCJyZXBsYWNlRW50aXRpZXNWYWx1ZSIsInJlYWRTdG9wTm9kZURhdGEiLCJzYXZlVGV4dFRvUGFyZW50VGFnIiwiYWRkQ2hpbGQiLCJpZ25vcmVBdHRyaWJ1dGVzRm4iLCJpZ25vcmVBdHRyaWJ1dGVzIiwiZXh0ZXJuYWxFbnRpdGllcyIsImVudEtleXMiLCJPYmplY3QiLCJrZXlzIiwiaSIsImxlbmd0aCIsImVudCIsIlJlZ0V4cCIsInRhZ05hbWUiLCJqUGF0aCIsImRvbnRUcmltIiwiaGFzQXR0cmlidXRlcyIsImlzTGVhZk5vZGUiLCJlc2NhcGVFbnRpdGllcyIsInVuZGVmaW5lZCIsInRyaW1WYWx1ZXMiLCJ0cmltIiwibmV3dmFsIiwidGFnVmFsdWVQcm9jZXNzb3IiLCJwYXJzZVZhbHVlIiwicGFyc2VUYWdWYWx1ZSIsIm51bWJlclBhcnNlT3B0aW9ucyIsInRyaW1tZWRWYWwiLCJ0YWduYW1lIiwicmVtb3ZlTlNQcmVmaXgiLCJ0YWdzIiwic3BsaXQiLCJwcmVmaXgiLCJjaGFyQXQiLCJhdHRyc1JlZ3giLCJhdHRyU3RyIiwibWF0Y2hlcyIsImxlbiIsImF0dHJzIiwiYXR0ck5hbWUiLCJvbGRWYWwiLCJhTmFtZSIsImF0dHJpYnV0ZU5hbWVQcmVmaXgiLCJ0cmFuc2Zvcm1BdHRyaWJ1dGVOYW1lIiwibmV3VmFsIiwiYXR0cmlidXRlVmFsdWVQcm9jZXNzb3IiLCJwYXJzZUF0dHJpYnV0ZVZhbHVlIiwiYWxsb3dCb29sZWFuQXR0cmlidXRlcyIsImF0dHJpYnV0ZXNHcm91cE5hbWUiLCJhdHRyQ29sbGVjdGlvbiIsInhtbERhdGEiLCJyZXBsYWNlIiwieG1sT2JqIiwidGV4dERhdGEiLCJjaCIsImNsb3NlSW5kZXgiLCJmaW5kQ2xvc2luZ0luZGV4Iiwic3Vic3RyaW5nIiwiY29sb25JbmRleCIsImluZGV4T2YiLCJzdWJzdHIiLCJ0cmFuc2Zvcm1UYWdOYW1lIiwibGFzdFRhZ05hbWUiLCJsYXN0SW5kZXhPZiIsInVucGFpcmVkVGFncyIsIkVycm9yIiwicHJvcEluZGV4IiwicG9wIiwidGFnRGF0YSIsInJlYWRUYWdFeHAiLCJpZ25vcmVEZWNsYXJhdGlvbiIsImlnbm9yZVBpVGFncyIsImNoaWxkTm9kZSIsImFkZCIsInRleHROb2RlTmFtZSIsInRhZ0V4cCIsImF0dHJFeHBQcmVzZW50IiwiZW5kSW5kZXgiLCJjb21tZW50UHJvcE5hbWUiLCJjb21tZW50IiwicmVzdWx0IiwiZW50aXRpZXMiLCJjZGF0YVByb3BOYW1lIiwicmF3VGFnTmFtZSIsImxhc3RUYWciLCJzdGFydEluZGV4Iiwic3RvcE5vZGVzIiwidGFnQ29udGVudCIsInB1c2giLCJjaGlsZCIsImNhcHR1cmVNZXRhRGF0YSIsInVwZGF0ZVRhZyIsInByb2Nlc3NFbnRpdGllcyIsImVudGl0eU5hbWUiLCJlbnRpdHkiLCJyZWd4IiwiY3VycmVudFRhZ05hbWUiLCJhbGxOb2Rlc0V4cCIsInN0b3BOb2RlUGF0aCIsInN0b3BOb2RlRXhwIiwidGFnRXhwV2l0aENsb3NpbmdJbmRleCIsImNsb3NpbmdDaGFyIiwiYXR0ckJvdW5kYXJ5IiwiaW5kZXgiLCJkYXRhIiwiZXJyTXNnIiwiY2xvc2luZ0luZGV4Iiwic2VwYXJhdG9ySW5kZXgiLCJzZWFyY2giLCJ0cmltU3RhcnQiLCJvcGVuVGFnQ291bnQiLCJjbG9zZVRhZ05hbWUiLCJvcGVuVGFnTmFtZSIsInNob3VsZFBhcnNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js":
/*!******************************************************************!*\
  !*** ../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ XMLParser)\n/* harmony export */ });\n/* harmony import */ var _OptionsBuilder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OptionsBuilder.js */ \"(rsc)/../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js\");\n/* harmony import */ var _OrderedObjParser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OrderedObjParser.js */ \"(rsc)/../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js\");\n/* harmony import */ var _node2json_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./node2json.js */ \"(rsc)/../node_modules/fast-xml-parser/src/xmlparser/node2json.js\");\n/* harmony import */ var _validator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../validator.js */ \"(rsc)/../node_modules/fast-xml-parser/src/validator.js\");\n/* harmony import */ var _xmlNode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./xmlNode.js */ \"(rsc)/../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\");\n\n\n\n\n\nclass XMLParser {\n    constructor(options){\n        this.externalEntities = {};\n        this.options = (0,_OptionsBuilder_js__WEBPACK_IMPORTED_MODULE_0__.buildOptions)(options);\n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */ parse(xmlData, validationOption) {\n        if (typeof xmlData === \"string\") {} else if (xmlData.toString) {\n            xmlData = xmlData.toString();\n        } else {\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\");\n        }\n        if (validationOption) {\n            if (validationOption === true) validationOption = {}; //validate with default options\n            const result = (0,_validator_js__WEBPACK_IMPORTED_MODULE_1__.validate)(xmlData, validationOption);\n            if (result !== true) {\n                throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);\n            }\n        }\n        const orderedObjParser = new _OrderedObjParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if (this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return (0,_node2json_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(orderedResult, this.options);\n    }\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */ addEntity(key, value) {\n        if (value.indexOf(\"&\") !== -1) {\n            throw new Error(\"Entity value can't have '&'\");\n        } else if (key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1) {\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\");\n        } else if (value === \"&\") {\n            throw new Error(\"An entity with value '&' is not permitted\");\n        } else {\n            this.externalEntities[key] = value;\n        }\n    }\n    /**\n     * Returns a Symbol that can be used to access the metadata\n     * property on a node.\n     * \n     * If Symbol is not available in the environment, an ordinary property is used\n     * and the name of the property is here returned.\n     * \n     * The XMLMetaData property is only present when `captureMetaData`\n     * is true in the options.\n     */ static getMetaDataSymbol() {\n        return _xmlNode_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].getMetaDataSymbol();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL1hNTFBhcnNlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0Q7QUFDRztBQUNmO0FBQ0c7QUFDTjtBQUVwQixNQUFNSztJQUVqQkMsWUFBWUMsT0FBTyxDQUFDO1FBQ2hCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUcsQ0FBQztRQUN6QixJQUFJLENBQUNELE9BQU8sR0FBR1AsZ0VBQVlBLENBQUNPO0lBRWhDO0lBQ0E7Ozs7S0FJQyxHQUNERSxNQUFNQyxPQUFPLEVBQUNDLGdCQUFnQixFQUFDO1FBQzNCLElBQUcsT0FBT0QsWUFBWSxVQUFTLENBQy9CLE9BQU0sSUFBSUEsUUFBUUUsUUFBUSxFQUFDO1lBQ3ZCRixVQUFVQSxRQUFRRSxRQUFRO1FBQzlCLE9BQUs7WUFDRCxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJRixrQkFBaUI7WUFDakIsSUFBR0EscUJBQXFCLE1BQU1BLG1CQUFtQixDQUFDLEdBQUcsK0JBQStCO1lBRXBGLE1BQU1HLFNBQVNYLHVEQUFRQSxDQUFDTyxTQUFTQztZQUNqQyxJQUFJRyxXQUFXLE1BQU07Z0JBQ25CLE1BQU1ELE1BQU8sQ0FBQyxFQUFFQyxPQUFPQyxHQUFHLENBQUNDLEdBQUcsQ0FBQyxDQUFDLEVBQUVGLE9BQU9DLEdBQUcsQ0FBQ0UsSUFBSSxDQUFDLENBQUMsRUFBRUgsT0FBT0MsR0FBRyxDQUFDRyxHQUFHLENBQUMsQ0FBQztZQUN2RTtRQUNGO1FBQ0YsTUFBTUMsbUJBQW1CLElBQUlsQiw0REFBZ0JBLENBQUMsSUFBSSxDQUFDTSxPQUFPO1FBQzFEWSxpQkFBaUJDLG1CQUFtQixDQUFDLElBQUksQ0FBQ1osZ0JBQWdCO1FBQzFELE1BQU1hLGdCQUFnQkYsaUJBQWlCRyxRQUFRLENBQUNaO1FBQ2hELElBQUcsSUFBSSxDQUFDSCxPQUFPLENBQUNnQixhQUFhLElBQUlGLGtCQUFrQkcsV0FBVyxPQUFPSDthQUNoRSxPQUFPbkIseURBQVFBLENBQUNtQixlQUFlLElBQUksQ0FBQ2QsT0FBTztJQUNwRDtJQUVBOzs7O0tBSUMsR0FDRGtCLFVBQVVDLEdBQUcsRUFBRUMsS0FBSyxFQUFDO1FBQ2pCLElBQUdBLE1BQU1DLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRTtZQUN6QixNQUFNLElBQUlmLE1BQU07UUFDcEIsT0FBTSxJQUFHYSxJQUFJRSxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUtGLElBQUlFLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRTtZQUN4RCxNQUFNLElBQUlmLE1BQU07UUFDcEIsT0FBTSxJQUFHYyxVQUFVLEtBQUk7WUFDbkIsTUFBTSxJQUFJZCxNQUFNO1FBQ3BCLE9BQUs7WUFDRCxJQUFJLENBQUNMLGdCQUFnQixDQUFDa0IsSUFBSSxHQUFHQztRQUNqQztJQUNKO0lBRUE7Ozs7Ozs7OztLQVNDLEdBQ0QsT0FBT0Usb0JBQW9CO1FBQ3ZCLE9BQU96QixtREFBT0EsQ0FBQ3lCLGlCQUFpQjtJQUNwQztBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FsZXMtZGFzaGJvYXJkLWZyb250ZW5kLy4uL25vZGVfbW9kdWxlcy9mYXN0LXhtbC1wYXJzZXIvc3JjL3htbHBhcnNlci9YTUxQYXJzZXIuanM/NjE4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBidWlsZE9wdGlvbnN9IGZyb20gJy4vT3B0aW9uc0J1aWxkZXIuanMnO1xuaW1wb3J0IE9yZGVyZWRPYmpQYXJzZXIgZnJvbSAnLi9PcmRlcmVkT2JqUGFyc2VyLmpzJztcbmltcG9ydCBwcmV0dGlmeSBmcm9tICcuL25vZGUyanNvbi5qcyc7XG5pbXBvcnQge3ZhbGlkYXRlfSBmcm9tIFwiLi4vdmFsaWRhdG9yLmpzXCI7XG5pbXBvcnQgWG1sTm9kZSBmcm9tICcuL3htbE5vZGUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBYTUxQYXJzZXJ7XG4gICAgXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyl7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxFbnRpdGllcyA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBidWlsZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBYTUwgZGF0cyB0byBKUyBvYmplY3QgXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSB4bWxEYXRhIFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R9IHZhbGlkYXRpb25PcHRpb24gXG4gICAgICovXG4gICAgcGFyc2UoeG1sRGF0YSx2YWxpZGF0aW9uT3B0aW9uKXtcbiAgICAgICAgaWYodHlwZW9mIHhtbERhdGEgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICB9ZWxzZSBpZiggeG1sRGF0YS50b1N0cmluZyl7XG4gICAgICAgICAgICB4bWxEYXRhID0geG1sRGF0YS50b1N0cmluZygpO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlhNTCBkYXRhIGlzIGFjY2VwdGVkIGluIFN0cmluZyBvciBCeXRlc1tdIGZvcm0uXCIpXG4gICAgICAgIH1cbiAgICAgICAgaWYoIHZhbGlkYXRpb25PcHRpb24pe1xuICAgICAgICAgICAgaWYodmFsaWRhdGlvbk9wdGlvbiA9PT0gdHJ1ZSkgdmFsaWRhdGlvbk9wdGlvbiA9IHt9OyAvL3ZhbGlkYXRlIHdpdGggZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHhtbERhdGEsIHZhbGlkYXRpb25PcHRpb24pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvciggYCR7cmVzdWx0LmVyci5tc2d9OiR7cmVzdWx0LmVyci5saW5lfToke3Jlc3VsdC5lcnIuY29sfWAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JkZXJlZE9ialBhcnNlciA9IG5ldyBPcmRlcmVkT2JqUGFyc2VyKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIG9yZGVyZWRPYmpQYXJzZXIuYWRkRXh0ZXJuYWxFbnRpdGllcyh0aGlzLmV4dGVybmFsRW50aXRpZXMpO1xuICAgICAgICBjb25zdCBvcmRlcmVkUmVzdWx0ID0gb3JkZXJlZE9ialBhcnNlci5wYXJzZVhtbCh4bWxEYXRhKTtcbiAgICAgICAgaWYodGhpcy5vcHRpb25zLnByZXNlcnZlT3JkZXIgfHwgb3JkZXJlZFJlc3VsdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gb3JkZXJlZFJlc3VsdDtcbiAgICAgICAgZWxzZSByZXR1cm4gcHJldHRpZnkob3JkZXJlZFJlc3VsdCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgRW50aXR5IHdoaWNoIGlzIG5vdCBieSBkZWZhdWx0IHN1cHBvcnRlZCBieSB0aGlzIGxpYnJhcnlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBcbiAgICAgKi9cbiAgICBhZGRFbnRpdHkoa2V5LCB2YWx1ZSl7XG4gICAgICAgIGlmKHZhbHVlLmluZGV4T2YoXCImXCIpICE9PSAtMSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnRpdHkgdmFsdWUgY2FuJ3QgaGF2ZSAnJidcIilcbiAgICAgICAgfWVsc2UgaWYoa2V5LmluZGV4T2YoXCImXCIpICE9PSAtMSB8fCBrZXkuaW5kZXhPZihcIjtcIikgIT09IC0xKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIGVudGl0eSBtdXN0IGJlIHNldCB3aXRob3V0ICcmJyBhbmQgJzsnLiBFZy4gdXNlICcjeEQnIGZvciAnJiN4RDsnXCIpXG4gICAgICAgIH1lbHNlIGlmKHZhbHVlID09PSBcIiZcIil7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBlbnRpdHkgd2l0aCB2YWx1ZSAnJicgaXMgbm90IHBlcm1pdHRlZFwiKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRW50aXRpZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFN5bWJvbCB0aGF0IGNhbiBiZSB1c2VkIHRvIGFjY2VzcyB0aGUgbWV0YWRhdGFcbiAgICAgKiBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAgICogXG4gICAgICogSWYgU3ltYm9sIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGVudmlyb25tZW50LCBhbiBvcmRpbmFyeSBwcm9wZXJ0eSBpcyB1c2VkXG4gICAgICogYW5kIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBpcyBoZXJlIHJldHVybmVkLlxuICAgICAqIFxuICAgICAqIFRoZSBYTUxNZXRhRGF0YSBwcm9wZXJ0eSBpcyBvbmx5IHByZXNlbnQgd2hlbiBgY2FwdHVyZU1ldGFEYXRhYFxuICAgICAqIGlzIHRydWUgaW4gdGhlIG9wdGlvbnMuXG4gICAgICovXG4gICAgc3RhdGljIGdldE1ldGFEYXRhU3ltYm9sKCkge1xuICAgICAgICByZXR1cm4gWG1sTm9kZS5nZXRNZXRhRGF0YVN5bWJvbCgpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJidWlsZE9wdGlvbnMiLCJPcmRlcmVkT2JqUGFyc2VyIiwicHJldHRpZnkiLCJ2YWxpZGF0ZSIsIlhtbE5vZGUiLCJYTUxQYXJzZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJleHRlcm5hbEVudGl0aWVzIiwicGFyc2UiLCJ4bWxEYXRhIiwidmFsaWRhdGlvbk9wdGlvbiIsInRvU3RyaW5nIiwiRXJyb3IiLCJyZXN1bHQiLCJlcnIiLCJtc2ciLCJsaW5lIiwiY29sIiwib3JkZXJlZE9ialBhcnNlciIsImFkZEV4dGVybmFsRW50aXRpZXMiLCJvcmRlcmVkUmVzdWx0IiwicGFyc2VYbWwiLCJwcmVzZXJ2ZU9yZGVyIiwidW5kZWZpbmVkIiwiYWRkRW50aXR5Iiwia2V5IiwidmFsdWUiLCJpbmRleE9mIiwiZ2V0TWV0YURhdGFTeW1ib2wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/fast-xml-parser/src/xmlparser/node2json.js":
/*!******************************************************************!*\
  !*** ../node_modules/fast-xml-parser/src/xmlparser/node2json.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ prettify)\n/* harmony export */ });\n/* harmony import */ var _xmlNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./xmlNode.js */ \"(rsc)/../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\");\n\n\nconst METADATA_SYMBOL = _xmlNode_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getMetaDataSymbol();\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */ function prettify(node, options) {\n    return compress(node, options);\n}\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */ function compress(arr, options, jPath) {\n    let text;\n    const compressedObj = {};\n    for(let i = 0; i < arr.length; i++){\n        const tagObj = arr[i];\n        const property = propName(tagObj);\n        let newJpath = \"\";\n        if (jPath === undefined) newJpath = property;\n        else newJpath = jPath + \".\" + property;\n        if (property === options.textNodeName) {\n            if (text === undefined) text = tagObj[property];\n            else text += \"\" + tagObj[property];\n        } else if (property === undefined) {\n            continue;\n        } else if (tagObj[property]) {\n            let val = compress(tagObj[property], options, newJpath);\n            const isLeaf = isLeafTag(val, options);\n            if (tagObj[METADATA_SYMBOL] !== undefined) {\n                val[METADATA_SYMBOL] = tagObj[METADATA_SYMBOL]; // copy over metadata\n            }\n            if (tagObj[\":@\"]) {\n                assignAttributes(val, tagObj[\":@\"], newJpath, options);\n            } else if (Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode) {\n                val = val[options.textNodeName];\n            } else if (Object.keys(val).length === 0) {\n                if (options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n                else val = \"\";\n            }\n            if (compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n                if (!Array.isArray(compressedObj[property])) {\n                    compressedObj[property] = [\n                        compressedObj[property]\n                    ];\n                }\n                compressedObj[property].push(val);\n            } else {\n                //TODO: if a node is not an array, then check if it should be an array\n                //also determine if it is a leaf node\n                if (options.isArray(property, newJpath, isLeaf)) {\n                    compressedObj[property] = [\n                        val\n                    ];\n                } else {\n                    compressedObj[property] = val;\n                }\n            }\n        }\n    }\n    // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n    if (typeof text === \"string\") {\n        if (text.length > 0) compressedObj[options.textNodeName] = text;\n    } else if (text !== undefined) compressedObj[options.textNodeName] = text;\n    return compressedObj;\n}\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for(let i = 0; i < keys.length; i++){\n        const key = keys[i];\n        if (key !== \":@\") return key;\n    }\n}\nfunction assignAttributes(obj, attrMap, jpath, options) {\n    if (attrMap) {\n        const keys = Object.keys(attrMap);\n        const len = keys.length; //don't make it inline\n        for(let i = 0; i < len; i++){\n            const atrrName = keys[i];\n            if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n                obj[atrrName] = [\n                    attrMap[atrrName]\n                ];\n            } else {\n                obj[atrrName] = attrMap[atrrName];\n            }\n        }\n    }\n}\nfunction isLeafTag(obj, options) {\n    const { textNodeName } = options;\n    const propCount = Object.keys(obj).length;\n    if (propCount === 0) {\n        return true;\n    }\n    if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)) {\n        return true;\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL25vZGUyanNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBRW1DO0FBRW5DLE1BQU1DLGtCQUFrQkQsbURBQU9BLENBQUNFLGlCQUFpQjtBQUVqRDs7Ozs7Q0FLQyxHQUNjLFNBQVNDLFNBQVNDLElBQUksRUFBRUMsT0FBTztJQUM1QyxPQUFPQyxTQUFVRixNQUFNQztBQUN6QjtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLFNBQVNDLEdBQUcsRUFBRUYsT0FBTyxFQUFFRyxLQUFLO0lBQ25DLElBQUlDO0lBQ0osTUFBTUMsZ0JBQWdCLENBQUM7SUFDdkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlKLElBQUlLLE1BQU0sRUFBRUQsSUFBSztRQUNuQyxNQUFNRSxTQUFTTixHQUFHLENBQUNJLEVBQUU7UUFDckIsTUFBTUcsV0FBV0MsU0FBU0Y7UUFDMUIsSUFBSUcsV0FBVztRQUNmLElBQUdSLFVBQVVTLFdBQVdELFdBQVdGO2FBQzlCRSxXQUFXUixRQUFRLE1BQU1NO1FBRTlCLElBQUdBLGFBQWFULFFBQVFhLFlBQVksRUFBQztZQUNuQyxJQUFHVCxTQUFTUSxXQUFXUixPQUFPSSxNQUFNLENBQUNDLFNBQVM7aUJBQ3pDTCxRQUFRLEtBQUtJLE1BQU0sQ0FBQ0MsU0FBUztRQUNwQyxPQUFNLElBQUdBLGFBQWFHLFdBQVU7WUFDOUI7UUFDRixPQUFNLElBQUdKLE1BQU0sQ0FBQ0MsU0FBUyxFQUFDO1lBRXhCLElBQUlLLE1BQU1iLFNBQVNPLE1BQU0sQ0FBQ0MsU0FBUyxFQUFFVCxTQUFTVztZQUM5QyxNQUFNSSxTQUFTQyxVQUFVRixLQUFLZDtZQUM5QixJQUFJUSxNQUFNLENBQUNaLGdCQUFnQixLQUFLZ0IsV0FBVztnQkFDekNFLEdBQUcsQ0FBQ2xCLGdCQUFnQixHQUFHWSxNQUFNLENBQUNaLGdCQUFnQixFQUFFLHFCQUFxQjtZQUN2RTtZQUVBLElBQUdZ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LENBQUNaLGFBQWEsS0FBSyxhQUFhWSxHQUFHLENBQUNaLGFBQWEsS0FBSyxJQUN0RjtRQUNBLE9BQU87SUFDVDtJQUVBLE9BQU87QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWRhc2hib2FyZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIvbm9kZTJqc29uLmpzPzAzZjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgWG1sTm9kZSBmcm9tICcuL3htbE5vZGUuanMnO1xuXG5jb25zdCBNRVRBREFUQV9TWU1CT0wgPSBYbWxOb2RlLmdldE1ldGFEYXRhU3ltYm9sKCk7XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge2FycmF5fSBub2RlIFxuICogQHBhcmFtIHthbnl9IG9wdGlvbnMgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJldHRpZnkobm9kZSwgb3B0aW9ucyl7XG4gIHJldHVybiBjb21wcmVzcyggbm9kZSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBcbiAqIEBwYXJhbSB7c3RyaW5nfSBqUGF0aCBcbiAqIEByZXR1cm5zIG9iamVjdFxuICovXG5mdW5jdGlvbiBjb21wcmVzcyhhcnIsIG9wdGlvbnMsIGpQYXRoKXtcbiAgbGV0IHRleHQ7XG4gIGNvbnN0IGNvbXByZXNzZWRPYmogPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0YWdPYmogPSBhcnJbaV07XG4gICAgY29uc3QgcHJvcGVydHkgPSBwcm9wTmFtZSh0YWdPYmopO1xuICAgIGxldCBuZXdKcGF0aCA9IFwiXCI7XG4gICAgaWYoalBhdGggPT09IHVuZGVmaW5lZCkgbmV3SnBhdGggPSBwcm9wZXJ0eTtcbiAgICBlbHNlIG5ld0pwYXRoID0galBhdGggKyBcIi5cIiArIHByb3BlcnR5O1xuXG4gICAgaWYocHJvcGVydHkgPT09IG9wdGlvbnMudGV4dE5vZGVOYW1lKXtcbiAgICAgIGlmKHRleHQgPT09IHVuZGVmaW5lZCkgdGV4dCA9IHRhZ09ialtwcm9wZXJ0eV07XG4gICAgICBlbHNlIHRleHQgKz0gXCJcIiArIHRhZ09ialtwcm9wZXJ0eV07XG4gICAgfWVsc2UgaWYocHJvcGVydHkgPT09IHVuZGVmaW5lZCl7XG4gICAgICBjb250aW51ZTtcbiAgICB9ZWxzZSBpZih0YWdPYmpbcHJvcGVydHldKXtcbiAgICAgIFxuICAgICAgbGV0IHZhbCA9IGNvbXByZXNzKHRhZ09ialtwcm9wZXJ0eV0sIG9wdGlvbnMsIG5ld0pwYXRoKTtcbiAgICAgIGNvbnN0IGlzTGVhZiA9IGlzTGVhZlRhZyh2YWwsIG9wdGlvbnMpO1xuICAgICAgaWYgKHRhZ09ialtNRVRBREFUQV9TWU1CT0xdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsW01FVEFEQVRBX1NZTUJPTF0gPSB0YWdPYmpbTUVUQURBVEFfU1lNQk9MXTsgLy8gY29weSBvdmVyIG1ldGFkYXRhXG4gICAgICB9XG5cbiAgICAgIGlmKHRhZ09ialtcIjpAXCJdKXtcbiAgICAgICAgYXNzaWduQXR0cmlidXRlcyggdmFsLCB0YWdPYmpbXCI6QFwiXSwgbmV3SnBhdGgsIG9wdGlvbnMpO1xuICAgICAgfWVsc2UgaWYoT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDEgJiYgdmFsW29wdGlvbnMudGV4dE5vZGVOYW1lXSAhPT0gdW5kZWZpbmVkICYmICFvcHRpb25zLmFsd2F5c0NyZWF0ZVRleHROb2RlKXtcbiAgICAgICAgdmFsID0gdmFsW29wdGlvbnMudGV4dE5vZGVOYW1lXTtcbiAgICAgIH1lbHNlIGlmKE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwKXtcbiAgICAgICAgaWYob3B0aW9ucy5hbHdheXNDcmVhdGVUZXh0Tm9kZSkgdmFsW29wdGlvbnMudGV4dE5vZGVOYW1lXSA9IFwiXCI7XG4gICAgICAgIGVsc2UgdmFsID0gXCJcIjtcbiAgICAgIH1cblxuICAgICAgaWYoY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCAmJiBjb21wcmVzc2VkT2JqLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICBpZighQXJyYXkuaXNBcnJheShjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIGNvbXByZXNzZWRPYmpbcHJvcGVydHldID0gWyBjb21wcmVzc2VkT2JqW3Byb3BlcnR5XSBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbXByZXNzZWRPYmpbcHJvcGVydHldLnB1c2godmFsKTtcbiAgICAgIH1lbHNle1xuICAgICAgICAvL1RPRE86IGlmIGEgbm9kZSBpcyBub3QgYW4gYXJyYXksIHRoZW4gY2hlY2sgaWYgaXQgc2hvdWxkIGJlIGFuIGFycmF5XG4gICAgICAgIC8vYWxzbyBkZXRlcm1pbmUgaWYgaXQgaXMgYSBsZWFmIG5vZGVcbiAgICAgICAgaWYgKG9wdGlvbnMuaXNBcnJheShwcm9wZXJ0eSwgbmV3SnBhdGgsIGlzTGVhZiApKSB7XG4gICAgICAgICAgY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gPSBbdmFsXTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgY29tcHJlc3NlZE9ialtwcm9wZXJ0eV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gIH1cbiAgLy8gaWYodGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIGNvbXByZXNzZWRPYmpbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdID0gdGV4dDtcbiAgaWYodHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIpe1xuICAgIGlmKHRleHQubGVuZ3RoID4gMCkgY29tcHJlc3NlZE9ialtvcHRpb25zLnRleHROb2RlTmFtZV0gPSB0ZXh0O1xuICB9ZWxzZSBpZih0ZXh0ICE9PSB1bmRlZmluZWQpIGNvbXByZXNzZWRPYmpbb3B0aW9ucy50ZXh0Tm9kZU5hbWVdID0gdGV4dDtcbiAgcmV0dXJuIGNvbXByZXNzZWRPYmo7XG59XG5cbmZ1bmN0aW9uIHByb3BOYW1lKG9iail7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmKGtleSAhPT0gXCI6QFwiKSByZXR1cm4ga2V5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkF0dHJpYnV0ZXMob2JqLCBhdHRyTWFwLCBqcGF0aCwgb3B0aW9ucyl7XG4gIGlmIChhdHRyTWFwKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGF0dHJNYXApO1xuICAgIGNvbnN0IGxlbiA9IGtleXMubGVuZ3RoOyAvL2Rvbid0IG1ha2UgaXQgaW5saW5lXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYXRyck5hbWUgPSBrZXlzW2ldO1xuICAgICAgaWYgKG9wdGlvbnMuaXNBcnJheShhdHJyTmFtZSwganBhdGggKyBcIi5cIiArIGF0cnJOYW1lLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICBvYmpbYXRyck5hbWVdID0gWyBhdHRyTWFwW2F0cnJOYW1lXSBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2F0cnJOYW1lXSA9IGF0dHJNYXBbYXRyck5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0xlYWZUYWcob2JqLCBvcHRpb25zKXtcbiAgY29uc3QgeyB0ZXh0Tm9kZU5hbWUgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHByb3BDb3VudCA9IE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xuICBcbiAgaWYgKHByb3BDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFxuICAgIHByb3BDb3VudCA9PT0gMSAmJlxuICAgIChvYmpbdGV4dE5vZGVOYW1lXSB8fCB0eXBlb2Ygb2JqW3RleHROb2RlTmFtZV0gPT09IFwiYm9vbGVhblwiIHx8IG9ialt0ZXh0Tm9kZU5hbWVdID09PSAwKVxuICApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6WyJYbWxOb2RlIiwiTUVUQURBVEFfU1lNQk9MIiwiZ2V0TWV0YURhdGFTeW1ib2wiLCJwcmV0dGlmeSIsIm5vZGUiLCJvcHRpb25zIiwiY29tcHJlc3MiLCJhcnIiLCJqUGF0aCIsInRleHQiLCJjb21wcmVzc2VkT2JqIiwiaSIsImxlbmd0aCIsInRhZ09iaiIsInByb3BlcnR5IiwicHJvcE5hbWUiLCJuZXdKcGF0aCIsInVuZGVmaW5lZCIsInRleHROb2RlTmFtZSIsInZhbCIsImlzTGVhZiIsImlzTGVhZlRhZyIsImFzc2lnbkF0dHJpYnV0ZXMiLCJPYmplY3QiLCJrZXlzIiwiYWx3YXlzQ3JlYXRlVGV4dE5vZGUiLCJoYXNPd25Qcm9wZXJ0eSIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJvYmoiLCJrZXkiLCJhdHRyTWFwIiwianBhdGgiLCJsZW4iLCJhdHJyTmFtZSIsInByb3BDb3VudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/fast-xml-parser/src/xmlparser/node2json.js\n");

/***/ }),

/***/ "(rsc)/../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js":
/*!****************************************************************!*\
  !*** ../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ XmlNode)\n/* harmony export */ });\n\nlet METADATA_SYMBOL;\nif (typeof Symbol !== \"function\") {\n    METADATA_SYMBOL = \"@@xmlMetadata\";\n} else {\n    METADATA_SYMBOL = Symbol(\"XML Node Metadata\");\n}\nclass XmlNode {\n    constructor(tagname){\n        this.tagname = tagname;\n        this.child = []; //nested tags, text, cdata, comments in order\n        this[\":@\"] = {}; //attributes map\n    }\n    add(key, val) {\n        // this.child.push( {name : key, val: val, isCdata: isCdata });\n        if (key === \"__proto__\") key = \"#__proto__\";\n        this.child.push({\n            [key]: val\n        });\n    }\n    addChild(node, startIndex) {\n        if (node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n        if (node[\":@\"] && Object.keys(node[\":@\"]).length > 0) {\n            this.child.push({\n                [node.tagname]: node.child,\n                [\":@\"]: node[\":@\"]\n            });\n        } else {\n            this.child.push({\n                [node.tagname]: node.child\n            });\n        }\n        // if requested, add the startIndex\n        if (startIndex !== undefined) {\n            // Note: for now we just overwrite the metadata. If we had more complex metadata,\n            // we might need to do an object append here:  metadata = { ...metadata, startIndex }\n            this.child[this.child.length - 1][METADATA_SYMBOL] = {\n                startIndex\n            };\n        }\n    }\n    /** symbol used for metadata */ static getMetaDataSymbol() {\n        return METADATA_SYMBOL;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzL2Zhc3QteG1sLXBhcnNlci9zcmMveG1scGFyc2VyL3htbE5vZGUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBRUEsSUFBSUE7QUFFSixJQUFJLE9BQU9DLFdBQVcsWUFBWTtJQUNoQ0Qsa0JBQWtCO0FBQ3BCLE9BQU87SUFDTEEsa0JBQWtCQyxPQUFPO0FBQzNCO0FBRWUsTUFBTUM7SUFDbkJDLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFLEVBQUUsNkNBQTZDO1FBQzlELElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLGdCQUFnQjtJQUNuQztJQUNBQyxJQUFJQyxHQUFHLEVBQUNDLEdBQUcsRUFBQztRQUNWLCtEQUErRDtRQUMvRCxJQUFHRCxRQUFRLGFBQWFBLE1BQU07UUFDOUIsSUFBSSxDQUFDRixLQUFLLENBQUNJLElBQUksQ0FBRTtZQUFDLENBQUNGLElBQUksRUFBRUM7UUFBSTtJQUMvQjtJQUNBRSxTQUFTQyxJQUFJLEVBQUVDLFVBQVUsRUFBRTtRQUN6QixJQUFHRCxLQUFLUCxPQUFPLEtBQUssYUFBYU8sS0FBS1AsT0FBTyxHQUFHO1FBQ2hELElBQUdPLElBQUksQ0FBQyxLQUFLLElBQUlFLE9BQU9DLElBQUksQ0FBQ0gsSUFBSSxDQUFDLEtBQUssRUFBRUksTUFBTSxHQUFHLEdBQUU7WUFDbEQsSUFBSSxDQUFDVixLQUFLLENBQUNJLElBQUksQ0FBRTtnQkFBRSxDQUFDRSxLQUFLUCxPQUFPLENBQUMsRUFBRU8sS0FBS04sS0FBSztnQkFBRSxDQUFDLEtBQUssRUFBRU0sSUFBSSxDQUFDLEtBQUs7WUFBQztRQUNwRSxPQUFLO1lBQ0gsSUFBSSxDQUFDTixLQUFLLENBQUNJLElBQUksQ0FBRTtnQkFBRSxDQUFDRSxLQUFLUCxPQUFPLENBQUMsRUFBRU8sS0FBS04sS0FBSztZQUFDO1FBQ2hEO1FBQ0EsbUNBQW1DO1FBQ25DLElBQUlPLGVBQWVJLFdBQVc7WUFDNUIsaUZBQWlGO1lBQ2pGLHFGQUFxRjtZQUNyRixJQUFJLENBQUNYLEtBQUssQ0FBQyxJQUFJLENBQUNBLEtBQUssQ0FBQ1UsTUFBTSxHQUFHLEVBQUUsQ0FBQ2YsZ0JBQWdCLEdBQUc7Z0JBQUVZO1lBQVc7UUFDcEU7SUFDRjtJQUNBLDZCQUE2QixHQUM3QixPQUFPSyxvQkFBb0I7UUFDekIsT0FBT2pCO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbGVzLWRhc2hib2FyZC1mcm9udGVuZC8uLi9ub2RlX21vZHVsZXMvZmFzdC14bWwtcGFyc2VyL3NyYy94bWxwYXJzZXIveG1sTm9kZS5qcz8yZDhmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubGV0IE1FVEFEQVRBX1NZTUJPTDtcblxuaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwiZnVuY3Rpb25cIikge1xuICBNRVRBREFUQV9TWU1CT0wgPSBcIkBAeG1sTWV0YWRhdGFcIjtcbn0gZWxzZSB7XG4gIE1FVEFEQVRBX1NZTUJPTCA9IFN5bWJvbChcIlhNTCBOb2RlIE1ldGFkYXRhXCIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBYbWxOb2Rle1xuICBjb25zdHJ1Y3Rvcih0YWduYW1lKSB7XG4gICAgdGhpcy50YWduYW1lID0gdGFnbmFtZTtcbiAgICB0aGlzLmNoaWxkID0gW107IC8vbmVzdGVkIHRhZ3MsIHRleHQsIGNkYXRhLCBjb21tZW50cyBpbiBvcmRlclxuICAgIHRoaXNbXCI6QFwiXSA9IHt9OyAvL2F0dHJpYnV0ZXMgbWFwXG4gIH1cbiAgYWRkKGtleSx2YWwpe1xuICAgIC8vIHRoaXMuY2hpbGQucHVzaCgge25hbWUgOiBrZXksIHZhbDogdmFsLCBpc0NkYXRhOiBpc0NkYXRhIH0pO1xuICAgIGlmKGtleSA9PT0gXCJfX3Byb3RvX19cIikga2V5ID0gXCIjX19wcm90b19fXCI7XG4gICAgdGhpcy5jaGlsZC5wdXNoKCB7W2tleV06IHZhbCB9KTtcbiAgfVxuICBhZGRDaGlsZChub2RlLCBzdGFydEluZGV4KSB7XG4gICAgaWYobm9kZS50YWduYW1lID09PSBcIl9fcHJvdG9fX1wiKSBub2RlLnRhZ25hbWUgPSBcIiNfX3Byb3RvX19cIjtcbiAgICBpZihub2RlW1wiOkBcIl0gJiYgT2JqZWN0LmtleXMobm9kZVtcIjpAXCJdKS5sZW5ndGggPiAwKXtcbiAgICAgIHRoaXMuY2hpbGQucHVzaCggeyBbbm9kZS50YWduYW1lXTogbm9kZS5jaGlsZCwgW1wiOkBcIl06IG5vZGVbXCI6QFwiXSB9KTtcbiAgICB9ZWxzZXtcbiAgICAgIHRoaXMuY2hpbGQucHVzaCggeyBbbm9kZS50YWduYW1lXTogbm9kZS5jaGlsZCB9KTtcbiAgICB9XG4gICAgLy8gaWYgcmVxdWVzdGVkLCBhZGQgdGhlIHN0YXJ0SW5kZXhcbiAgICBpZiAoc3RhcnRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBOb3RlOiBmb3Igbm93IHdlIGp1c3Qgb3ZlcndyaXRlIHRoZSBtZXRhZGF0YS4gSWYgd2UgaGFkIG1vcmUgY29tcGxleCBtZXRhZGF0YSxcbiAgICAgIC8vIHdlIG1pZ2h0IG5lZWQgdG8gZG8gYW4gb2JqZWN0IGFwcGVuZCBoZXJlOiAgbWV0YWRhdGEgPSB7IC4uLm1ldGFkYXRhLCBzdGFydEluZGV4IH1cbiAgICAgIHRoaXMuY2hpbGRbdGhpcy5jaGlsZC5sZW5ndGggLSAxXVtNRVRBREFUQV9TWU1CT0xdID0geyBzdGFydEluZGV4IH07XG4gICAgfVxuICB9XG4gIC8qKiBzeW1ib2wgdXNlZCBmb3IgbWV0YWRhdGEgKi9cbiAgc3RhdGljIGdldE1ldGFEYXRhU3ltYm9sKCkge1xuICAgIHJldHVybiBNRVRBREFUQV9TWU1CT0w7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJNRVRBREFUQV9TWU1CT0wiLCJTeW1ib2wiLCJYbWxOb2RlIiwiY29uc3RydWN0b3IiLCJ0YWduYW1lIiwiY2hpbGQiLCJhZGQiLCJrZXkiLCJ2YWwiLCJwdXNoIiwiYWRkQ2hpbGQiLCJub2RlIiwic3RhcnRJbmRleCIsIk9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJnZXRNZXRhRGF0YVN5bWJvbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js\n");

/***/ })

};
;